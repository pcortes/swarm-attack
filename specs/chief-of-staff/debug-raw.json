{
  "type": "result",
  "subtype": "success",
  "is_error": false,
  "duration_ms": 306851,
  "duration_api_ms": 368926,
  "num_turns": 6,
  "result": "Now I have a good understanding of the existing codebase. Let me produce the revised spec addressing all the critic's issues:\n\n<<<SPEC_START>>>\n# Engineering Spec: Chief of Staff Agent\n\n## 1. Overview\n\n### 1.1 Purpose\n\nThe Chief of Staff agent is a strategic orchestration layer for swarm-attack that acts as an autonomous \"mini-CEO\" for the repository. It provides:\n\n1. **Cross-Session Memory**: Persistent tracking of goals, decisions, and outcomes across Claude Code sessions\n2. **Daily Standups**: Interactive morning briefings that summarize yesterday's progress vs plan and recommend today's priorities\n3. **Plan Tracking**: Goal setting with measurable achievement tracking, automatic status reconciliation, and carryover logic\n4. **Autonomous Execution**: Autopilot mode that executes work within budget/time constraints with checkpoint gates and pause/resume capability\n\n### 1.2 Scope\n\n**In Scope:**\n- State gathering from all repository data sources (git, PRDs, specs, features, bugs, sessions, GitHub)\n- Daily log persistence in human-readable markdown format\n- Decision logging in append-only JSONL format\n- Interactive standup command with recommendations\n- Plan tracking with goal completion metrics and automatic status reconciliation\n- Autopilot mode with configurable checkpoints, pause/resume, and --until trigger support\n\n**Out of Scope:**\n- Multi-repository support (single repo only)\n- Calendar/scheduling integration\n- Preference learning from human decisions (Phase 6, future)\n- Actual cost tracking via API (uses estimated costs from existing tracking)\n\n### 1.3 Success Criteria\n\n| Criterion | Metric | Target |\n|-----------|--------|--------|\n| Daily continuity | Sessions able to recall yesterday's plan | 100% |\n| Goal achievement tracking | Accurate completion % calculation | 100% accuracy |\n| Time to context | Standup provides full context | < 30 seconds |\n| Checkpoint accuracy | Appropriate trigger frequency | No false negatives |\n| State gathering | All sources aggregated | 100% coverage |\n| Autopilot pause/resume | Sessions resumable after checkpoint | 100% reliability |\n\n---\n\n## 2. Architecture\n\n### 2.1 High-Level Design\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         CHIEF OF STAFF AGENT                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n\u2502  \u2502 DailyLogMgr   \u2502  \u2502 GoalTracker   \u2502  \u2502 AutopilotRun  \u2502               \u2502\n\u2502  \u2502               \u2502  \u2502               \u2502  \u2502               \u2502               \u2502\n\u2502  \u2502 \u2022 Read/write  \u2502  \u2502 \u2022 Set goals   \u2502  \u2502 \u2022 Execute     \u2502               \u2502\n\u2502  \u2502 \u2022 Decision log\u2502  \u2502 \u2022 Track status\u2502  \u2502 \u2022 Checkpoints \u2502               \u2502\n\u2502  \u2502 \u2022 History     \u2502  \u2502 \u2022 Reconcile   \u2502  \u2502 \u2022 Budget/time \u2502               \u2502\n\u2502  \u2502               \u2502  \u2502   with state  \u2502  \u2502 \u2022 Pause/resume\u2502               \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2502          \u2502                 \u2502                  \u2502                         \u2502\n\u2502          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502\n\u2502                            \u25bc                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502                      StateGatherer                               \u2502   \u2502\n\u2502  \u2502                                                                  \u2502   \u2502\n\u2502  \u2502  Sources:                                                        \u2502   \u2502\n\u2502  \u2502  \u2022 GitStateSource      (branch, commits, status, diff)          \u2502   \u2502\n\u2502  \u2502  \u2022 PRDStateSource      (.claude/prds/*.md + frontmatter)        \u2502   \u2502\n\u2502  \u2502  \u2022 SpecStateSource     (.claude/specs/*.md)                     \u2502   \u2502\n\u2502  \u2502  \u2022 FeatureStateSource  (.swarm/state/*.json)                    \u2502   \u2502\n\u2502  \u2502  \u2022 BugStateSource      (.swarm/bugs/*/state.json)               \u2502   \u2502\n\u2502  \u2502  \u2022 SessionStateSource  (.swarm/sessions/*/*.json)               \u2502   \u2502\n\u2502  \u2502  \u2022 GitHubStateSource   (issues, PRs via gh CLI)                 \u2502   \u2502\n\u2502  \u2502  \u2022 TestStateSource     (pytest collection + last run)           \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502                    CheckpointSystem                              \u2502   \u2502\n\u2502  \u2502                                                                  \u2502   \u2502\n\u2502  \u2502  Triggers:                                                       \u2502   \u2502\n\u2502  \u2502  \u2022 CostThreshold       (configurable, e.g., $10)                \u2502   \u2502\n\u2502  \u2502  \u2022 TimeThreshold       (configurable, e.g., 2 hours)            \u2502   \u2502\n\u2502  \u2502  \u2022 BlockerDetected     (can't proceed without human input)      \u2502   \u2502\n\u2502  \u2502  \u2022 ApprovalRequired    (spec approval, fix approval)            \u2502   \u2502\n\u2502  \u2502  \u2022 HighRiskAction      (architectural change, main push)        \u2502   \u2502\n\u2502  \u2502  \u2022 ErrorRateSpike      (3+ consecutive failures)                \u2502   \u2502\n\u2502  \u2502  \u2022 EndOfSession        (natural stopping point)                 \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502                  AutopilotSessionStore                           \u2502   \u2502\n\u2502  \u2502                                                                  \u2502   \u2502\n\u2502  \u2502  Persistence for pause/resume:                                   \u2502   \u2502\n\u2502  \u2502  \u2022 .swarm/chief-of-staff/autopilot/{session_id}.json            \u2502   \u2502\n\u2502  \u2502  \u2022 Tracks goals, progress, checkpoints, cost, duration          \u2502   \u2502\n\u2502  \u2502  \u2022 Enables resume(session_id) after checkpoint pause            \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### 2.2 Components\n\n| Component | File | Responsibility |\n|-----------|------|----------------|\n| `StateGatherer` | `swarm_attack/chief_of_staff/state_gatherer.py` | Aggregate state from all data sources |\n| `DailyLogManager` | `swarm_attack/chief_of_staff/daily_log.py` | Read/write daily logs, decision JSONL |\n| `GoalTracker` | `swarm_attack/chief_of_staff/goal_tracker.py` | Manage goals, track completion, reconcile with state |\n| `CheckpointSystem` | `swarm_attack/chief_of_staff/checkpoints.py` | Detect checkpoint triggers |\n| `AutopilotRunner` | `swarm_attack/chief_of_staff/autopilot.py` | Execute work with checkpoints, pause/resume |\n| `AutopilotSessionStore` | `swarm_attack/chief_of_staff/autopilot_store.py` | Persist autopilot sessions for resume |\n| `StandupGenerator` | `swarm_attack/chief_of_staff/standup.py` | Generate standup report |\n| `ChiefOfStaffConfig` | `swarm_attack/chief_of_staff/config.py` | Configuration dataclass |\n\n### 2.3 Data Flow\n\n```\nstandup command\n     \u2502\n     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 StateGatherer  \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 RepoStateSnap  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502DailyLogManager \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Yesterday Log  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502StandupGenerator\u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Standup Report \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  GoalTracker   \u2502\u25c0\u2500\u2500\u2500\u2500\u2502 User Input     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502DailyLogManager \u2502\u25c0\u2500\u2500\u2500\u2500\u2502 Today's Plan   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n## 3. Data Models\n\n### 3.1 Core State Models\n\n```python\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, date\nfrom enum import Enum\nfrom typing import Optional, Any, Literal\n\n\nclass GoalStatus(Enum):\n    \"\"\"Status of a daily goal.\"\"\"\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    DONE = \"done\"\n    PARTIAL = \"partial\"\n    SKIPPED = \"skipped\"\n    BLOCKED = \"blocked\"\n\n\nclass CheckpointTrigger(Enum):\n    \"\"\"Types of checkpoint triggers.\"\"\"\n    COST_THRESHOLD = \"cost_threshold_reached\"\n    TIME_THRESHOLD = \"time_threshold_reached\"\n    BLOCKER_DETECTED = \"blocker_detected\"\n    APPROVAL_REQUIRED = \"approval_required\"\n    HIGH_RISK_ACTION = \"high_risk_action\"\n    ERROR_RATE_SPIKE = \"error_rate_spike\"\n    END_OF_SESSION = \"end_of_session\"\n\n\n@dataclass\nclass DailyGoal:\n    \"\"\"A single goal for the day.\"\"\"\n    id: str                                    # Unique identifier (e.g., \"goal-001\")\n    content: str                               # Goal description\n    priority: Literal[\"P1\", \"P2\", \"P3\"]       # Priority level\n    status: GoalStatus = GoalStatus.PENDING\n    estimated_minutes: Optional[int] = None\n    actual_minutes: Optional[int] = None\n    notes: str = \"\"\n    linked_feature: Optional[str] = None      # Feature ID if applicable\n    linked_bug: Optional[str] = None          # Bug ID if applicable\n    linked_spec: Optional[str] = None         # Spec feature ID if applicable\n    completed_at: Optional[str] = None        # ISO timestamp\n\n    def to_dict(self) -> dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        return {\n            \"id\": self.id,\n            \"content\": self.content,\n            \"priority\": self.priority,\n            \"status\": self.status.value,\n            \"estimated_minutes\": self.estimated_minutes,\n            \"actual_minutes\": self.actual_minutes,\n            \"notes\": self.notes,\n            \"linked_feature\": self.linked_feature,\n            \"linked_bug\": self.linked_bug,\n            \"linked_spec\": self.linked_spec,\n            \"completed_at\": self.completed_at,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -> \"DailyGoal\":\n        \"\"\"Create from dictionary.\"\"\"\n        data = data.copy()\n        data[\"status\"] = GoalStatus(data[\"status\"])\n        return cls(**data)\n\n\n@dataclass\nclass Decision:\n    \"\"\"A decision made during the day.\"\"\"\n    timestamp: str                            # ISO format\n    type: str                                 # \"approval\", \"priority\", \"checkpoint\", \"skip\", etc.\n    item: str                                 # What the decision is about\n    decision: str                             # The actual decision made\n    rationale: str                            # Why this decision was made\n    human_override: bool = False              # Was this a human override of recommendation?\n    metadata: dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -> dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        return {\n            \"timestamp\": self.timestamp,\n            \"type\": self.type,\n            \"item\": self.item,\n            \"decision\": self.decision,\n            \"rationale\": self.rationale,\n            \"human_override\": self.human_override,\n            \"metadata\": self.metadata,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -> \"Decision\":\n        \"\"\"Create from dictionary.\"\"\"\n        return cls(**data)\n\n\n@dataclass\nclass WorkLogEntry:\n    \"\"\"A single entry in the work log.\"\"\"\n    timestamp: str                            # ISO format\n    action: str                               # What was done\n    result: str                               # Outcome\n    cost_usd: float = 0.0                     # Cost of this action\n    duration_seconds: int = 0                 # Duration if applicable\n    checkpoint: Optional[str] = None          # Checkpoint trigger if paused\n\n    def to_dict(self) -> dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        return {\n            \"timestamp\": self.timestamp,\n            \"action\": self.action,\n            \"result\": self.result,\n            \"cost_usd\": self.cost_usd,\n            \"duration_seconds\": self.duration_seconds,\n            \"checkpoint\": self.checkpoint,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -> \"WorkLogEntry\":\n        \"\"\"Create from dictionary.\"\"\"\n        return cls(**data)\n\n\n@dataclass\nclass StandupSession:\n    \"\"\"Record of a standup session.\"\"\"\n    session_id: str                           # Unique session ID (e.g., \"cos-20251212-001\")\n    time: str                                 # ISO timestamp of standup\n    yesterday_goals: list[DailyGoal]          # Goals from yesterday\n    today_goals: list[DailyGoal]              # Goals set for today\n    philip_notes: str = \"\"                    # Notes from human\n    recommendations_accepted: bool = False     # Did human accept recommendations?\n\n    def to_dict(self) -> dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        return {\n            \"session_id\": self.session_id,\n            \"time\": self.time,\n            \"yesterday_goals\": [g.to_dict() for g in self.yesterday_goals],\n            \"today_goals\": [g.to_dict() for g in self.today_goals],\n            \"philip_notes\": self.philip_notes,\n            \"recommendations_accepted\": self.recommendations_accepted,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -> \"StandupSession\":\n        \"\"\"Create from dictionary.\"\"\"\n        data = data.copy()\n        data[\"yesterday_goals\"] = [DailyGoal.from_dict(g) for g in data.get(\"yesterday_goals\", [])]\n        data[\"today_goals\"] = [DailyGoal.from_dict(g) for g in data.get(\"today_goals\", [])]\n        return cls(**data)\n\n\n@dataclass\nclass DailySummary:\n    \"\"\"End-of-day summary.\"\"\"\n    goals_completed: int\n    goals_total: int\n    total_cost_usd: float\n    key_accomplishments: list[str]\n    blockers_for_tomorrow: list[str]\n    carryover_goals: list[DailyGoal]\n\n    def to_dict(self) -> dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        return {\n            \"goals_completed\": self.goals_completed,\n            \"goals_total\": self.goals_total,\n            \"total_cost_usd\": self.total_cost_usd,\n            \"key_accomplishments\": self.key_accomplishments,\n            \"blockers_for_tomorrow\": self.blockers_for_tomorrow,\n            \"carryover_goals\": [g.to_dict() for g in self.carryover_goals],\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -> \"DailySummary\":\n        \"\"\"Create from dictionary.\"\"\"\n        data = data.copy()\n        data[\"carryover_goals\"] = [DailyGoal.from_dict(g) for g in data.get(\"carryover_goals\", [])]\n        return cls(**data)\n\n\n@dataclass\nclass DailyLog:\n    \"\"\"Complete daily log for a single day.\"\"\"\n    date: str                                 # YYYY-MM-DD format\n    standups: list[StandupSession] = field(default_factory=list)\n    work_log: list[WorkLogEntry] = field(default_factory=list)\n    summary: Optional[DailySummary] = None\n    created_at: str = \"\"                      # ISO timestamp\n    updated_at: str = \"\"                      # ISO timestamp\n\n    def __post_init__(self) -> None:\n        \"\"\"Set timestamps if not provided.\"\"\"\n        now = datetime.now().isoformat()\n        if not self.created_at:\n            self.created_at = now\n        if not self.updated_at:\n            self.updated_at = now\n\n    def to_dict(self) -> dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        return {\n            \"date\": self.date,\n            \"standups\": [s.to_dict() for s in self.standups],\n            \"work_log\": [w.to_dict() for w in self.work_log],\n            \"summary\": self.summary.to_dict() if self.summary else None,\n            \"created_at\": self.created_at,\n            \"updated_at\": self.updated_at,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -> \"DailyLog\":\n        \"\"\"Create from dictionary.\"\"\"\n        data = data.copy()\n        data[\"standups\"] = [StandupSession.from_dict(s) for s in data.get(\"standups\", [])]\n        data[\"work_log\"] = [WorkLogEntry.from_dict(w) for w in data.get(\"work_log\", [])]\n        if data.get(\"summary\"):\n            data[\"summary\"] = DailySummary.from_dict(data[\"summary\"])\n        return cls(**data)\n```\n\n### 3.2 State Snapshot Models\n\n```python\n@dataclass\nclass GitState:\n    \"\"\"Current git state.\"\"\"\n    branch: str\n    is_clean: bool\n    uncommitted_files: list[str]\n    recent_commits: list[dict[str, str]]      # [{hash, message, author, date}]\n    ahead_behind: tuple[int, int]             # (ahead, behind) from remote\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"branch\": self.branch,\n            \"is_clean\": self.is_clean,\n            \"uncommitted_files\": self.uncommitted_files,\n            \"recent_commits\": self.recent_commits,\n            \"ahead_behind\": self.ahead_behind,\n        }\n\n\n@dataclass\nclass FeatureSummary:\n    \"\"\"Summary of a feature's state.\"\"\"\n    feature_id: str\n    phase: str                                # FeaturePhase.name\n    tasks_done: int\n    tasks_total: int\n    tasks_blocked: int\n    cost_usd: float\n    updated_at: str\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"feature_id\": self.feature_id,\n            \"phase\": self.phase,\n            \"tasks_done\": self.tasks_done,\n            \"tasks_total\": self.tasks_total,\n            \"tasks_blocked\": self.tasks_blocked,\n            \"cost_usd\": self.cost_usd,\n            \"updated_at\": self.updated_at,\n        }\n\n\n@dataclass\nclass BugSummary:\n    \"\"\"Summary of a bug's state.\"\"\"\n    bug_id: str\n    phase: str                                # BugPhase.value\n    cost_usd: float\n    updated_at: str\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"bug_id\": self.bug_id,\n            \"phase\": self.phase,\n            \"cost_usd\": self.cost_usd,\n            \"updated_at\": self.updated_at,\n        }\n\n\n@dataclass\nclass PRDSummary:\n    \"\"\"Summary of a PRD.\"\"\"\n    feature_id: str\n    title: str\n    phase: str                                # From frontmatter or inferred\n    path: str\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"feature_id\": self.feature_id,\n            \"title\": self.title,\n            \"phase\": self.phase,\n            \"path\": self.path,\n        }\n\n\n@dataclass\nclass SpecSummary:\n    \"\"\"Summary of a spec file.\"\"\"\n    feature_id: str\n    title: str\n    path: str\n    has_review: bool                          # Whether spec-review.json exists\n    review_passed: bool                       # Whether review recommendation is \"APPROVE\"\n    review_scores: Optional[dict[str, float]] # Scores from review if present\n    updated_at: str\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"feature_id\": self.feature_id,\n            \"title\": self.title,\n            \"path\": self.path,\n            \"has_review\": self.has_review,\n            \"review_passed\": self.review_passed,\n            \"review_scores\": self.review_scores,\n            \"updated_at\": self.updated_at,\n        }\n\n\n@dataclass\nclass TestState:\n    \"\"\"Current test state.\"\"\"\n    total_tests: int\n    passing: int\n    failing: int\n    skipped: int\n    last_run_at: Optional[str]\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"total_tests\": self.total_tests,\n            \"passing\": self.passing,\n            \"failing\": self.failing,\n            \"skipped\": self.skipped,\n            \"last_run_at\": self.last_run_at,\n        }\n\n\n@dataclass\nclass GitHubState:\n    \"\"\"GitHub state from gh CLI.\"\"\"\n    open_issues: int\n    closed_issues_today: int\n    open_prs: int\n    pending_reviews: list[dict[str, Any]]     # PRs awaiting review\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"open_issues\": self.open_issues,\n            \"closed_issues_today\": self.closed_issues_today,\n            \"open_prs\": self.open_prs,\n            \"pending_reviews\": self.pending_reviews,\n        }\n\n\n@dataclass\nclass InterruptedSession:\n    \"\"\"An interrupted session that needs attention.\"\"\"\n    session_id: str\n    feature_id: str\n    issue_number: int\n    started_at: str\n    last_checkpoint: Optional[str]\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"session_id\": self.session_id,\n            \"feature_id\": self.feature_id,\n            \"issue_number\": self.issue_number,\n            \"started_at\": self.started_at,\n            \"last_checkpoint\": self.last_checkpoint,\n        }\n\n\n@dataclass\nclass RepoStateSnapshot:\n    \"\"\"Complete snapshot of repository state.\"\"\"\n    gathered_at: str                          # ISO timestamp\n    git: GitState\n    features: list[FeatureSummary]\n    bugs: list[BugSummary]\n    prds: list[PRDSummary]\n    specs: list[SpecSummary]                  # Spec pipeline status\n    tests: TestState\n    github: Optional[GitHubState]\n    interrupted_sessions: list[InterruptedSession]\n    total_cost_today: float\n    total_cost_week: float\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"gathered_at\": self.gathered_at,\n            \"git\": self.git.to_dict(),\n            \"features\": [f.to_dict() for f in self.features],\n            \"bugs\": [b.to_dict() for b in self.bugs],\n            \"prds\": [p.to_dict() for p in self.prds],\n            \"specs\": [s.to_dict() for s in self.specs],\n            \"tests\": self.tests.to_dict(),\n            \"github\": self.github.to_dict() if self.github else None,\n            \"interrupted_sessions\": [s.to_dict() for s in self.interrupted_sessions],\n            \"total_cost_today\": self.total_cost_today,\n            \"total_cost_week\": self.total_cost_week,\n        }\n```\n\n### 3.3 Recommendation Models\n\n```python\n@dataclass\nclass Recommendation:\n    \"\"\"A recommended action for today.\"\"\"\n    priority: Literal[\"P1\", \"P2\", \"P3\"]\n    task: str\n    estimated_cost_usd: float\n    estimated_minutes: int\n    rationale: str\n    linked_feature: Optional[str] = None\n    linked_bug: Optional[str] = None\n    linked_spec: Optional[str] = None         # Spec feature ID if spec-related\n    command: Optional[str] = None             # CLI command to execute\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"priority\": self.priority,\n            \"task\": self.task,\n            \"estimated_cost_usd\": self.estimated_cost_usd,\n            \"estimated_minutes\": self.estimated_minutes,\n            \"rationale\": self.rationale,\n            \"linked_feature\": self.linked_feature,\n            \"linked_bug\": self.linked_bug,\n            \"linked_spec\": self.linked_spec,\n            \"command\": self.command,\n        }\n\n\n@dataclass\nclass AttentionItem:\n    \"\"\"An item that needs human attention.\"\"\"\n    type: str                                 # \"approval\", \"blocker\", \"new\", \"regression\", \"spec_review\"\n    description: str\n    urgency: Literal[\"high\", \"medium\", \"low\"]\n    action: str                               # Suggested action\n    command: Optional[str] = None             # CLI command if applicable\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"type\": self.type,\n            \"description\": self.description,\n            \"urgency\": self.urgency,\n            \"action\": self.action,\n            \"command\": self.command,\n        }\n\n\n@dataclass\nclass StandupReport:\n    \"\"\"Generated standup report.\"\"\"\n    date: str\n    yesterday_comparison: dict[str, Any]      # Goals vs actual\n    repo_health: dict[str, Any]               # Summary of repo state\n    attention_items: list[AttentionItem]\n    blockers: list[str]\n    recommendations: list[Recommendation]\n    state_snapshot: RepoStateSnapshot\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"date\": self.date,\n            \"yesterday_comparison\": self.yesterday_comparison,\n            \"repo_health\": self.repo_health,\n            \"attention_items\": [a.to_dict() for a in self.attention_items],\n            \"blockers\": self.blockers,\n            \"recommendations\": [r.to_dict() for r in self.recommendations],\n            \"state_snapshot\": self.state_snapshot.to_dict(),\n        }\n```\n\n### 3.4 Autopilot Models\n\n```python\n@dataclass\nclass CheckpointEvent:\n    \"\"\"A checkpoint during autopilot execution.\"\"\"\n    timestamp: str\n    trigger: CheckpointTrigger\n    context: dict[str, Any]\n    action_taken: str                         # \"paused\", \"continued\", \"aborted\"\n    human_response: Optional[str] = None\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"timestamp\": self.timestamp,\n            \"trigger\": self.trigger.value,\n            \"context\": self.context,\n            \"action_taken\": self.action_taken,\n            \"human_response\": self.human_response,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -> \"CheckpointEvent\":\n        \"\"\"Create from dictionary.\"\"\"\n        data = data.copy()\n        data[\"trigger\"] = CheckpointTrigger(data[\"trigger\"])\n        return cls(**data)\n\n\n@dataclass\nclass AutopilotSession:\n    \"\"\"An autopilot execution session with persistence support.\"\"\"\n    session_id: str\n    started_at: str\n    budget_usd: float\n    duration_limit_seconds: int\n    stop_trigger: Optional[CheckpointTrigger] = None  # --until trigger\n    goals: list[DailyGoal] = field(default_factory=list)\n    current_goal_index: int = 0               # Index of goal being worked on\n    checkpoints: list[CheckpointEvent] = field(default_factory=list)\n    cost_spent_usd: float = 0.0\n    duration_seconds: int = 0\n    status: str = \"running\"                   # \"running\", \"completed\", \"paused\", \"aborted\"\n    pause_reason: Optional[str] = None        # Reason for pause if paused\n    ended_at: Optional[str] = None\n    last_persisted_at: Optional[str] = None   # When session was last saved\n\n    def to_dict(self) -> dict[str, Any]:\n        return {\n            \"session_id\": self.session_id,\n            \"started_at\": self.started_at,\n            \"budget_usd\": self.budget_usd,\n            \"duration_limit_seconds\": self.duration_limit_seconds,\n            \"stop_trigger\": self.stop_trigger.value if self.stop_trigger else None,\n            \"goals\": [g.to_dict() for g in self.goals],\n            \"current_goal_index\": self.current_goal_index,\n            \"checkpoints\": [c.to_dict() for c in self.checkpoints],\n            \"cost_spent_usd\": self.cost_spent_usd,\n            \"duration_seconds\": self.duration_seconds,\n            \"status\": self.status,\n            \"pause_reason\": self.pause_reason,\n            \"ended_at\": self.ended_at,\n            \"last_persisted_at\": self.last_persisted_at,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -> \"AutopilotSession\":\n        \"\"\"Create from dictionary.\"\"\"\n        data = data.copy()\n        if data.get(\"stop_trigger\"):\n            data[\"stop_trigger\"] = CheckpointTrigger(data[\"stop_trigger\"])\n        data[\"goals\"] = [DailyGoal.from_dict(g) for g in data.get(\"goals\", [])]\n        data[\"checkpoints\"] = [CheckpointEvent.from_dict(c) for c in data.get(\"checkpoints\", [])]\n        return cls(**data)\n```\n\n### 3.5 Schema Changes\n\nNo database schema changes required. All persistence is file-based:\n\n**New Directory Structure:**\n```\n.swarm/chief-of-staff/\n\u251c\u2500\u2500 config.yaml                    # User preferences, thresholds\n\u251c\u2500\u2500 daily-log/\n\u2502   \u251c\u2500\u2500 2025-12-12.md             # Human-readable daily log\n\u2502   \u251c\u2500\u2500 2025-12-12.json           # Machine-readable daily log\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 weekly-summary/\n\u2502   \u2514\u2500\u2500 2025-W50.md               # Auto-generated weekly rollup\n\u251c\u2500\u2500 decisions.jsonl                # Append-only decision log\n\u251c\u2500\u2500 autopilot/                     # Autopilot session persistence\n\u2502   \u251c\u2500\u2500 ap-20251212-001.json      # Session state for pause/resume\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 metrics.json                   # Running totals, averages\n```\n\n---\n\n## 4. API Design\n\n### 4.1 CLI Commands\n\n| Command | Description | Options |\n|---------|-------------|---------|\n| `swarm-attack standup` | Morning standup briefing | `--since DATETIME` |\n| `swarm-attack checkin` | Quick mid-day check | - |\n| `swarm-attack wrapup` | End of day summary | - |\n| `swarm-attack autopilot` | Autonomous execution | `--budget`, `--duration`, `--until`, `--dry-run`, `--resume` |\n| `swarm-attack history` | Review past logs | `--days N`, `--weekly`, `--decisions` |\n| `swarm-attack plan` | View/set goals | `show`, `set`, `status` |\n| `swarm-attack next --all` | Cross-feature recommendations | - |\n\n### 4.2 StateGatherer Interface\n\n```python\nclass StateGatherer:\n    \"\"\"Gathers state from all repository data sources.\"\"\"\n\n    def __init__(self, config: SwarmConfig) -> None:\n        \"\"\"Initialize with configuration.\"\"\"\n\n    def gather(self, include_github: bool = True) -> RepoStateSnapshot:\n        \"\"\"\n        Gather complete repository state snapshot.\n\n        Args:\n            include_github: Whether to query GitHub API (slower).\n\n        Returns:\n            Complete RepoStateSnapshot with all data sources.\n        \"\"\"\n\n    def gather_git_state(self) -> GitState:\n        \"\"\"Gather git repository state.\"\"\"\n\n    def gather_features(self) -> list[FeatureSummary]:\n        \"\"\"Gather all feature states from .swarm/state/*.json.\"\"\"\n\n    def gather_bugs(self) -> list[BugSummary]:\n        \"\"\"Gather all bug states from .swarm/bugs/*/state.json.\"\"\"\n\n    def gather_prds(self) -> list[PRDSummary]:\n        \"\"\"Gather all PRDs from .claude/prds/*.md.\"\"\"\n\n    def gather_specs(self) -> list[SpecSummary]:\n        \"\"\"\n        Gather all specs from specs/*/ directories.\n\n        For each spec directory:\n        - Reads spec-draft.md or spec.md\n        - Checks for spec-review.json\n        - Extracts review scores and recommendation\n\n        Returns:\n            List of SpecSummary objects.\n        \"\"\"\n\n    def gather_tests(self) -> TestState:\n        \"\"\"Gather test state from pytest.\"\"\"\n\n    def gather_github(self) -> Optional[GitHubState]:\n        \"\"\"Gather GitHub state via gh CLI.\"\"\"\n\n    def gather_interrupted_sessions(self) -> list[InterruptedSession]:\n        \"\"\"Find interrupted sessions across all features.\"\"\"\n\n    def calculate_costs(self) -> tuple[float, float]:\n        \"\"\"Calculate today's and this week's costs.\"\"\"\n```\n\n### 4.3 DailyLogManager Interface\n\n```python\nclass DailyLogManager:\n    \"\"\"Manages daily log persistence.\"\"\"\n\n    def __init__(self, base_path: Path) -> None:\n        \"\"\"Initialize with base storage path.\"\"\"\n\n    def get_log(self, date: date) -> Optional[DailyLog]:\n        \"\"\"Get daily log for a specific date.\"\"\"\n\n    def get_today(self) -> DailyLog:\n        \"\"\"Get or create today's log.\"\"\"\n\n    def get_yesterday(self) -> Optional[DailyLog]:\n        \"\"\"Get yesterday's log if it exists.\"\"\"\n\n    def save_log(self, log: DailyLog) -> None:\n        \"\"\"Save daily log to disk (both .md and .json).\"\"\"\n\n    def add_standup(self, standup: StandupSession) -> None:\n        \"\"\"Add a standup session to today's log.\"\"\"\n\n    def add_work_entry(self, entry: WorkLogEntry) -> None:\n        \"\"\"Add a work log entry to today's log.\"\"\"\n\n    def set_summary(self, summary: DailySummary) -> None:\n        \"\"\"Set end-of-day summary.\"\"\"\n\n    def append_decision(self, decision: Decision) -> None:\n        \"\"\"Append decision to decisions.jsonl.\"\"\"\n\n    def get_decisions(\n        self,\n        since: Optional[datetime] = None,\n        decision_type: Optional[str] = None,\n    ) -> list[Decision]:\n        \"\"\"Query decisions from the JSONL log.\"\"\"\n\n    def get_history(self, days: int = 7) -> list[DailyLog]:\n        \"\"\"Get logs for the last N days.\"\"\"\n\n    def generate_weekly_summary(self, week: int, year: int) -> str:\n        \"\"\"Generate weekly summary markdown.\"\"\"\n```\n\n### 4.4 GoalTracker Interface\n\n```python\nclass GoalTracker:\n    \"\"\"Tracks daily goals and their completion with automatic state reconciliation.\"\"\"\n\n    def __init__(self, daily_log_manager: DailyLogManager) -> None:\n        \"\"\"Initialize with log manager.\"\"\"\n\n    def get_today_goals(self) -> list[DailyGoal]:\n        \"\"\"Get current goals for today.\"\"\"\n\n    def set_goals(self, goals: list[DailyGoal]) -> None:\n        \"\"\"Set goals for today.\"\"\"\n\n    def update_goal(self, goal_id: str, status: GoalStatus, notes: str = \"\") -> None:\n        \"\"\"Update a goal's status.\"\"\"\n\n    def mark_complete(self, goal_id: str, actual_minutes: Optional[int] = None) -> None:\n        \"\"\"Mark a goal as complete.\"\"\"\n\n    def get_yesterday_goals(self) -> list[DailyGoal]:\n        \"\"\"Get yesterday's goals for comparison.\"\"\"\n\n    def compare_plan_vs_actual(self) -> dict[str, Any]:\n        \"\"\"\n        Compare yesterday's plan vs actual results.\n\n        Returns:\n            Dictionary with:\n            - goals: list of {goal, planned, actual, status}\n            - completion_rate: float (0-1)\n            - time_accuracy: float (planned vs actual time)\n        \"\"\"\n\n    def get_carryover_goals(self) -> list[DailyGoal]:\n        \"\"\"Get incomplete goals that should carry over.\"\"\"\n\n    def reconcile_with_state(self, snapshot: RepoStateSnapshot) -> list[dict[str, Any]]:\n        \"\"\"\n        Reconcile goal statuses with actual repository state.\n\n        For goals with linked_feature:\n        - If feature phase is COMPLETE -> mark goal DONE\n        - If feature phase is BLOCKED -> mark goal BLOCKED\n        - If feature phase advanced -> mark goal PARTIAL or IN_PROGRESS\n\n        For goals with linked_bug:\n        - If bug phase is \"fixed\" -> mark goal DONE\n        - If bug phase is \"blocked\" -> mark goal BLOCKED\n\n        For goals with linked_spec:\n        - If spec has passing review -> mark goal DONE\n        - If spec has failing review -> mark goal PARTIAL\n\n        Args:\n            snapshot: Current repository state.\n\n        Returns:\n            List of changes made: [{\"goal_id\": str, \"old_status\": str, \"new_status\": str, \"reason\": str}]\n        \"\"\"\n\n    def generate_recommendations(\n        self,\n        state: RepoStateSnapshot,\n    ) -> list[Recommendation]:\n        \"\"\"\n        Generate recommended goals based on current state.\n\n        Priority rules:\n        1. P1: Blockers, approvals needed, regressions, spec reviews\n        2. P2: In-progress work, natural next steps\n        3. P3: New features, cleanup, nice-to-haves\n        \"\"\"\n```\n\n### 4.5 CheckpointSystem Interface\n\n```python\nclass CheckpointSystem:\n    \"\"\"Detects and handles checkpoint triggers.\"\"\"\n\n    def __init__(self, config: ChiefOfStaffConfig) -> None:\n        \"\"\"Initialize with configuration.\"\"\"\n\n    def check_triggers(\n        self,\n        session: AutopilotSession,\n        current_action: str,\n    ) -> Optional[CheckpointTrigger]:\n        \"\"\"\n        Check if any checkpoint should be triggered.\n\n        Checks in order:\n        1. If session.stop_trigger matches current state -> return that trigger\n        2. If cost >= budget -> COST_THRESHOLD\n        3. If duration >= limit -> TIME_THRESHOLD\n        4. If action requires approval -> APPROVAL_REQUIRED\n        5. If action is high risk -> HIGH_RISK_ACTION\n        6. If error streak >= threshold -> ERROR_RATE_SPIKE\n        7. If action is blocked -> BLOCKER_DETECTED\n\n        Args:\n            session: Current autopilot session state.\n            current_action: Action about to be taken.\n\n        Returns:\n            CheckpointTrigger if one should fire, None otherwise.\n        \"\"\"\n\n    def matches_stop_trigger(\n        self,\n        session: AutopilotSession,\n        trigger: CheckpointTrigger,\n    ) -> bool:\n        \"\"\"Check if trigger matches the session's --until stop trigger.\"\"\"\n\n    def is_high_risk(self, action: str) -> bool:\n        \"\"\"Check if an action is high-risk.\"\"\"\n\n    def record_error(self) -> None:\n        \"\"\"Record an error for spike detection.\"\"\"\n\n    def reset_error_count(self) -> None:\n        \"\"\"Reset error count after success.\"\"\"\n\n    def should_pause_for_approval(self, action: str) -> bool:\n        \"\"\"Check if action requires human approval.\"\"\"\n```\n\n### 4.6 AutopilotSessionStore Interface\n\n```python\nclass AutopilotSessionStore:\n    \"\"\"Persists autopilot sessions for pause/resume capability.\"\"\"\n\n    def __init__(self, base_path: Path) -> None:\n        \"\"\"Initialize with storage path (.swarm/chief-of-staff/autopilot/).\"\"\"\n\n    def save(self, session: AutopilotSession) -> None:\n        \"\"\"\n        Save autopilot session to disk atomically.\n\n        Uses atomic write pattern: temp file -> validate -> rename.\n        Sets session.last_persisted_at on save.\n        \"\"\"\n\n    def load(self, session_id: str) -> Optional[AutopilotSession]:\n        \"\"\"Load autopilot session from disk.\"\"\"\n\n    def list_paused(self) -> list[str]:\n        \"\"\"List all paused session IDs.\"\"\"\n\n    def list_all(self) -> list[str]:\n        \"\"\"List all session IDs.\"\"\"\n\n    def delete(self, session_id: str) -> None:\n        \"\"\"Delete a session file.\"\"\"\n\n    def get_latest_paused(self) -> Optional[AutopilotSession]:\n        \"\"\"Get the most recently paused session.\"\"\"\n```\n\n### 4.7 AutopilotRunner Interface\n\n```python\nclass AutopilotRunner:\n    \"\"\"Executes work autonomously with checkpoint enforcement and pause/resume.\"\"\"\n\n    def __init__(\n        self,\n        config: SwarmConfig,\n        checkpoint_system: CheckpointSystem,\n        goal_tracker: GoalTracker,\n        session_store: AutopilotSessionStore,\n        orchestrator: Orchestrator,\n        bug_orchestrator: BugOrchestrator,\n    ) -> None:\n        \"\"\"Initialize with dependencies.\"\"\"\n\n    def start(\n        self,\n        goals: list[DailyGoal],\n        budget_usd: float = 10.0,\n        duration_seconds: int = 7200,\n        stop_trigger: Optional[CheckpointTrigger] = None,\n    ) -> AutopilotSession:\n        \"\"\"\n        Start autopilot execution.\n\n        Args:\n            goals: Goals to work on (in priority order).\n            budget_usd: Maximum spend before checkpoint.\n            duration_seconds: Maximum duration before checkpoint.\n            stop_trigger: Optional trigger to stop at (--until).\n\n        Returns:\n            AutopilotSession tracking the execution.\n        \"\"\"\n\n    def resume(self, session_id: str) -> AutopilotSession:\n        \"\"\"\n        Resume a paused autopilot session.\n\n        Loads session from AutopilotSessionStore, validates it can be resumed,\n        and continues execution from where it left off.\n\n        Args:\n            session_id: ID of paused session to resume.\n\n        Returns:\n            AutopilotSession with continued execution.\n\n        Raises:\n            ValueError: If session not found or not resumable.\n        \"\"\"\n\n    def execute_goal(self, goal: DailyGoal) -> tuple[bool, float]:\n        \"\"\"\n        Execute a single goal.\n\n        Returns:\n            Tuple of (success, cost_usd).\n        \"\"\"\n\n    def handle_checkpoint(\n        self,\n        session: AutopilotSession,\n        trigger: CheckpointTrigger,\n    ) -> str:\n        \"\"\"\n        Handle a checkpoint trigger.\n\n        Persists session state before pausing to enable resume.\n\n        Returns:\n            \"continue\", \"pause\", or \"abort\".\n        \"\"\"\n\n    def get_status(self, session_id: str) -> Optional[AutopilotSession]:\n        \"\"\"Get status of an autopilot session.\"\"\"\n\n    def _persist_session(self, session: AutopilotSession) -> None:\n        \"\"\"Persist session state for pause/resume.\"\"\"\n```\n\n---\n\n## 5. Implementation Plan\n\n### 5.1 Tasks\n\n| # | Task | Dependencies | Size | Files |\n|---|------|--------------|------|-------|\n| 1 | Create data models | None | M | `swarm_attack/chief_of_staff/models.py` |\n| 2 | Implement StateGatherer | 1 | L | `swarm_attack/chief_of_staff/state_gatherer.py` |\n| 2a | Add gather_specs method | 2 | S | `swarm_attack/chief_of_staff/state_gatherer.py` |\n| 3 | Implement DailyLogManager | 1 | M | `swarm_attack/chief_of_staff/daily_log.py` |\n| 4 | Implement GoalTracker | 1, 3 | M | `swarm_attack/chief_of_staff/goal_tracker.py` |\n| 4a | Add reconcile_with_state method | 4 | M | `swarm_attack/chief_of_staff/goal_tracker.py` |\n| 5 | Implement CheckpointSystem | 1 | S | `swarm_attack/chief_of_staff/checkpoints.py` |\n| 5a | Add --until trigger support | 5 | S | `swarm_attack/chief_of_staff/checkpoints.py` |\n| 6 | Implement StandupGenerator | 2, 3, 4 | M | `swarm_attack/chief_of_staff/standup.py` |\n| 7 | Add ChiefOfStaffConfig | None | S | `swarm_attack/chief_of_staff/config.py` |\n| 8 | Integrate config into SwarmConfig | 7 | S | `swarm_attack/config.py` |\n| 9 | Implement CLI: standup | 2, 3, 4, 6 | M | `swarm_attack/cli.py` |\n| 10 | Implement CLI: checkin | 2 | S | `swarm_attack/cli.py` |\n| 11 | Implement CLI: wrapup | 3, 4 | S | `swarm_attack/cli.py` |\n| 12 | Implement CLI: plan | 4 | S | `swarm_attack/cli.py` |\n| 13 | Implement CLI: history | 3 | S | `swarm_attack/cli.py` |\n| 14 | Implement AutopilotSessionStore | 1 | M | `swarm_attack/chief_of_staff/autopilot_store.py` |\n| 15 | Implement AutopilotRunner | 4, 5, 14 | L | `swarm_attack/chief_of_staff/autopilot.py` |\n| 15a | Add resume() method | 15 | M | `swarm_attack/chief_of_staff/autopilot.py` |\n| 16 | Implement CLI: autopilot | 15 | M | `swarm_attack/cli.py` |\n| 16a | Add --until and --resume flags | 16 | S | `swarm_attack/cli.py` |\n| 17 | Implement CLI: next --all | 2, 4 | S | `swarm_attack/cli.py` |\n| 18 | Add unit tests | All | L | `tests/chief_of_staff/` |\n| 19 | Add integration tests | All | M | `tests/chief_of_staff/` |\n\n### 5.2 File Changes\n\n**New Files:**\n- `swarm_attack/chief_of_staff/__init__.py`\n- `swarm_attack/chief_of_staff/models.py`\n- `swarm_attack/chief_of_staff/config.py`\n- `swarm_attack/chief_of_staff/state_gatherer.py`\n- `swarm_attack/chief_of_staff/daily_log.py`\n- `swarm_attack/chief_of_staff/goal_tracker.py`\n- `swarm_attack/chief_of_staff/checkpoints.py`\n- `swarm_attack/chief_of_staff/standup.py`\n- `swarm_attack/chief_of_staff/autopilot_store.py`\n- `swarm_attack/chief_of_staff/autopilot.py`\n- `tests/chief_of_staff/__init__.py`\n- `tests/chief_of_staff/test_models.py`\n- `tests/chief_of_staff/test_state_gatherer.py`\n- `tests/chief_of_staff/test_daily_log.py`\n- `tests/chief_of_staff/test_goal_tracker.py`\n- `tests/chief_of_staff/test_checkpoints.py`\n- `tests/chief_of_staff/test_standup.py`\n- `tests/chief_of_staff/test_autopilot_store.py`\n- `tests/chief_of_staff/test_autopilot.py`\n\n**Modified Files:**\n- `swarm_attack/config.py` - Add ChiefOfStaffConfig\n- `swarm_attack/cli.py` - Add new commands\n\n---\n\n## 6. Testing Strategy\n\n### 6.1 Unit Tests\n\n| Component | Test Cases | Coverage Target |\n|-----------|------------|-----------------|\n| Data models | Serialization round-trip, validation | 95% |\n| StateGatherer | Each source isolated, aggregation, spec gathering | 85% |\n| DailyLogManager | CRUD operations, file locking | 90% |\n| GoalTracker | Goal operations, comparison logic, state reconciliation | 90% |\n| CheckpointSystem | Each trigger type, edge cases, --until matching | 90% |\n| StandupGenerator | Report generation, recommendations | 80% |\n| AutopilotSessionStore | Save/load, list operations, atomic writes | 90% |\n| AutopilotRunner | Execution flow, checkpoint handling, pause/resume | 80% |\n\n### 6.2 Integration Tests\n\n| Scenario | Description | Validation |\n|----------|-------------|------------|\n| Full standup flow | gather \u2192 compare \u2192 recommend \u2192 set goals | All components integrated |\n| Autopilot with checkpoints | Execute until cost/time limit | Checkpoint fires correctly |\n| Autopilot pause/resume | Pause at checkpoint, resume later | State preserved, execution continues |\n| Autopilot --until trigger | Stop at specific trigger | Correct trigger detection |\n| Multi-day continuity | Run standup on day 2 | Yesterday's data loaded |\n| Recovery from interrupted | Session interrupted mid-execution | State preserved, resumable |\n| Goal state reconciliation | Goals linked to features/bugs | Status auto-updates |\n| Spec pipeline visibility | Spec reviews in standup | Spec status displayed |\n\n### 6.3 Edge Cases\n\n| Case | Test |\n|------|------|\n| First run (no history) | Standup handles missing yesterday log |\n| Empty repository | StateGatherer handles no features/bugs/specs |\n| GitHub unavailable | StateGatherer degrades gracefully |\n| Corrupted daily log | DailyLogManager recovers from backup |\n| Clock rollback | Daily log handles date changes |\n| Concurrent access | File locking prevents corruption |\n| Autopilot resume with deleted goal | Resume handles goal no longer existing |\n| Spec without review | gather_specs handles missing spec-review.json |\n\n---\n\n## 7. Risks and Mitigations\n\n| Risk | Impact | Likelihood | Mitigation |\n|------|--------|------------|------------|\n| State gathering slow | Standup takes >30s | Medium | Cache GitHub results, parallelize sources |\n| Daily log corruption | Loss of history | Low | Atomic writes, JSON backup alongside markdown |\n| Autopilot runaway | Unexpected cost | Medium | Hard budget limits, mandatory checkpoints |\n| Goal tracking drift | Inaccurate metrics | Medium | reconcile_with_state validates against actual repo state |\n| Clock/timezone issues | Date mismatch | Low | Use UTC internally, convert for display |\n| gh CLI unavailable | No GitHub data | Low | Graceful degradation, warn user |\n| Autopilot resume data loss | Can't resume paused session | Medium | Persist session state before every checkpoint, atomic writes |\n| Spec parsing failures | Missing spec data | Low | Graceful degradation, log warnings |\n\n---\n\n## 8. Open Questions\n\n1. **Session Context**: Should the Chief of Staff operate within the main Claude Code session or maintain its own separate context?\n   - **Recommendation**: Operate within main session, persist state to files.\n\n2. **Multi-repo Support**: How should it handle multiple repositories?\n   - **Recommendation**: Defer to future. Current scope is single repo.\n\n3. **Calendar Integration**: Should it integrate with calendar for time-based planning?\n   - **Recommendation**: Out of scope for MVP. Can add later.\n\n4. **Auto-recovery Aggressiveness**: How aggressive should auto-recovery be?\n   - **Recommendation**: Conservative. Require human trigger for recovery actions.\n\n---\n\n## 9. Configuration\n\n### 9.1 Configuration Schema\n\n```yaml\n# Added to config.yaml under chief_of_staff:\nchief_of_staff:\n  # Checkpoint thresholds\n  checkpoints:\n    budget_usd: 10.0              # Pause after spending this much\n    duration_minutes: 120          # Pause after this long\n    error_streak: 3               # Pause after N consecutive errors\n\n  # Priority weights (0.0 - 1.0) for recommendation scoring\n  priorities:\n    blocker_weight: 1.0           # Blockers are highest priority\n    approval_weight: 0.9          # Human approvals needed\n    regression_weight: 0.85       # Test regressions\n    spec_review_weight: 0.88      # Spec reviews needing attention\n    in_progress_weight: 0.7       # Continue started work\n    new_feature_weight: 0.5       # Start new features\n\n  # Standup preferences\n  standup:\n    auto_run_on_start: false      # Run standup automatically\n    include_github: true          # Query GitHub for issues/PRs\n    include_tests: true           # Run pytest collection\n    include_specs: true           # Gather spec pipeline status\n    history_days: 7               # How far back to look\n\n  # Autopilot preferences\n  autopilot:\n    default_budget: 10.0          # Default budget in USD\n    default_duration: \"2h\"        # Default duration\n    pause_on_approval: true       # Always pause for approvals\n    pause_on_high_risk: true      # Always pause for risky ops\n    persist_on_checkpoint: true   # Always persist state at checkpoints\n\n  # Storage\n  storage_path: \".swarm/chief-of-staff\"\n```\n\n### 9.2 Configuration Dataclass\n\n```python\n@dataclass\nclass CheckpointConfig:\n    \"\"\"Checkpoint trigger configuration.\"\"\"\n    budget_usd: float = 10.0\n    duration_minutes: int = 120\n    error_streak: int = 3\n\n\n@dataclass\nclass PriorityConfig:\n    \"\"\"Priority weight configuration.\"\"\"\n    blocker_weight: float = 1.0\n    approval_weight: float = 0.9\n    regression_weight: float = 0.85\n    spec_review_weight: float = 0.88\n    in_progress_weight: float = 0.7\n    new_feature_weight: float = 0.5\n\n\n@dataclass\nclass StandupConfig:\n    \"\"\"Standup preferences.\"\"\"\n    auto_run_on_start: bool = False\n    include_github: bool = True\n    include_tests: bool = True\n    include_specs: bool = True\n    history_days: int = 7\n\n\n@dataclass\nclass AutopilotConfig:\n    \"\"\"Autopilot preferences.\"\"\"\n    default_budget: float = 10.0\n    default_duration: str = \"2h\"\n    pause_on_approval: bool = True\n    pause_on_high_risk: bool = True\n    persist_on_checkpoint: bool = True\n\n\n@dataclass\nclass ChiefOfStaffConfig:\n    \"\"\"Chief of Staff configuration.\"\"\"\n    checkpoints: CheckpointConfig = field(default_factory=CheckpointConfig)\n    priorities: PriorityConfig = field(default_factory=PriorityConfig)\n    standup: StandupConfig = field(default_factory=StandupConfig)\n    autopilot: AutopilotConfig = field(default_factory=AutopilotConfig)\n    storage_path: str = \".swarm/chief-of-staff\"\n```\n\n---\n\n## 10. CLI Output Formats\n\n### 10.1 Standup Output\n\n```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551  DAILY STANDUP - December 13, 2025                                           \u2551\n\u2551  swarm-attack v0.2.0 | Chief of Staff Agent                                  \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                              \u2551\n\u2551  \ud83d\udcc5 YESTERDAY'S PLAN vs ACTUAL                                               \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502 Goal                           \u2502 Planned \u2502 Actual  \u2502 Status            \u2502  \u2551\n\u2551  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2551\n\u2551  \u2502 Approve bug-bash spec          \u2502 5 min   \u2502 5 min   \u2502 \u2705 Done            \u2502  \u2551\n\u2551  \u2502 Build Chief of Staff PRD       \u2502 30 min  \u2502 45 min  \u2502 \u2705 Done            \u2502  \u2551\n\u2551  \u2502 Clean up test files            \u2502 10 min  \u2502 -       \u2502 \u23ed\ufe0f Skipped         \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                              \u2551\n\u2551  \ud83d\udcca REPO HEALTH                                                              \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502 Branch: master (clean)                                                 \u2502  \u2551\n\u2551  \u2502 Tests: 3/3 passing (100%)                                              \u2502  \u2551\n\u2551  \u2502 Features: 2 total                                                      \u2502  \u2551\n\u2551  \u2502   \u2022 bug-bash: SPEC_NEEDS_APPROVAL                                      \u2502  \u2551\n\u2551  \u2502   \u2022 chief-of-staff: PRD_READY (new)                                    \u2502  \u2551\n\u2551  \u2502 Specs: 2 total                                                         \u2502  \u2551\n\u2551  \u2502   \u2022 bug-bash: review PASSED (0.85 avg)                                 \u2502  \u2551\n\u2551  \u2502   \u2022 chief-of-staff: review PENDING                                     \u2502  \u2551\n\u2551  \u2502 Bugs: 1 fixed, 0 open                                                  \u2502  \u2551\n\u2551  \u2502 Spend: $0.37 yesterday | $5.20 this week                               \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                              \u2551\n\u2551  \ud83d\udd14 ITEMS NEEDING YOUR ATTENTION                                             \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502 1. [APPROVAL] bug-bash spec ready for review                           \u2502  \u2551\n\u2551  \u2502 2. [SPEC_REVIEW] chief-of-staff spec needs revision (0.61 avg)        \u2502  \u2551\n\u2551  \u2502 3. [NEW] chief-of-staff PRD created - ready for spec pipeline          \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                              \u2551\n\u2551  \ud83d\udd34 BLOCKERS                                                                 \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502 None currently                                                         \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                              \u2551\n\u2551  \ud83c\udfaf RECOMMENDED TODAY                                                        \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502 Pri \u2502 Task                                    \u2502 Est Cost \u2502 Est Time   \u2502  \u2551\n\u2551  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2551\n\u2551  \u2502 P1  \u2502 Approve bug-bash spec                   \u2502 $0       \u2502 5 min      \u2502  \u2551\n\u2551  \u2502 P1  \u2502 Run spec pipeline for chief-of-staff   \u2502 ~$1      \u2502 15 min     \u2502  \u2551\n\u2551  \u2502 P2  \u2502 Start bug-bash implementation          \u2502 ~$5      \u2502 1 hr       \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                              \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551  What would you like to focus on today?                                      \u2551\n\u2551                                                                              \u2551\n\u2551  [1] Accept recommendations and start                                        \u2551\n\u2551  [2] Modify priorities                                                       \u2551\n\u2551  [3] Autopilot: Execute P1 tasks, report back                                \u2551\n\u2551  [4] Something else                                                          \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```\n\n### 10.2 Autopilot Checkpoint Output\n\n```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551  CHECKPOINT: Approval Required                                               \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                              \u2551\n\u2551  chief-of-staff spec is ready for your review.                               \u2551\n\u2551                                                                              \u2551\n\u2551  Progress so far:                                                            \u2551\n\u2551  \u2022 bug-bash spec approved                                                    \u2551\n\u2551  \u2022 chief-of-staff spec generated                                             \u2551\n\u2551  \u2022 Cost: $1.20 / $10 budget                                                  \u2551\n\u2551  \u2022 Time: 15 min / 2h duration                                                \u2551\n\u2551                                                                              \u2551\n\u2551  Session state saved. You can resume with:                                   \u2551\n\u2551  swarm-attack autopilot --resume ap-20251213-001                             \u2551\n\u2551                                                                              \u2551\n\u2551  [1] Review and approve spec                                                 \u2551\n\u2551  [2] Review and request changes                                              \u2551\n\u2551  [3] Pause autopilot, I'll continue manually                                 \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```\n\n### 10.3 Daily Log Markdown Format\n\n```markdown\n# Daily Log: 2025-12-12\n\n## Morning Standup\n- **Time:** 08:30\n- **Session ID:** cos-20251212-001\n\n### Yesterday's Goals (from 2025-12-11)\n| Goal | Status | Notes |\n|------|--------|-------|\n| Fix RT blockers | Partial | #1 still blocked |\n| Test bug-bash | Done | Full pipeline validated |\n| Start new PRD | Skipped | Blockers took priority |\n\n### Current State Snapshot\n- **Features:** 1 (bug-bash @ SPEC_NEEDS_APPROVAL)\n- **Specs:** 1 (bug-bash @ review passed)\n- **Bugs:** 1 fixed, 0 open\n- **GitHub Issues:** 14 closed, 2 blocked\n- **Tests:** 3/3 passing\n- **Git:** master branch, clean\n\n### Today's Plan (agreed with Philip)\n1. [P1] Approve bug-bash spec\n2. [P2] Build Chief of Staff agent\n3. [P3] Clean up test files\n\n### Philip's Notes\n> \"Let's prioritize the Chief of Staff - it will pay dividends.\"\n\n---\n\n## Work Log\n\n### 09:15 - Approved bug-bash spec\n- Command: `swarm-attack approve bug-bash`\n- Result: Success\n- Cost: $0\n\n### 09:20 - Started Chief of Staff implementation\n- Created PRD\n- Cost: $0\n\n### 11:30 - CHECKPOINT: Spec ready for review\n- Spec generated for chief-of-staff\n- Awaiting Philip's approval\n- Cost so far: $2.50\n\n---\n\n## End of Day Summary\n- **Goals Completed:** 2/3\n- **Total Cost:** $5.20\n- **Key Accomplishments:**\n  - Chief of Staff PRD approved\n  - Spec generated and reviewed\n- **Blockers for Tomorrow:**\n  - None\n- **Carryover:**\n  - Clean up test files (low priority)\n```\n\n---\n\n## 11. Decision Log Format (JSONL)\n\nEach line in `decisions.jsonl` is a JSON object:\n\n```json\n{\"timestamp\": \"2025-12-12T09:15:00Z\", \"type\": \"approval\", \"item\": \"bug-bash-spec\", \"decision\": \"approved\", \"rationale\": \"Spec meets quality thresholds\", \"human_override\": false, \"metadata\": {\"scores\": {\"clarity\": 0.9, \"coverage\": 0.85}}}\n{\"timestamp\": \"2025-12-12T09:30:00Z\", \"type\": \"priority\", \"item\": \"chief-of-staff\", \"decision\": \"P1\", \"rationale\": \"Philip requested prioritization\", \"human_override\": true, \"metadata\": {\"original_priority\": \"P2\"}}\n{\"timestamp\": \"2025-12-12T11:30:00Z\", \"type\": \"checkpoint\", \"item\": \"autopilot-session-001\", \"decision\": \"paused\", \"rationale\": \"approval_required trigger\", \"human_override\": false, \"metadata\": {\"trigger\": \"approval_required\", \"context\": \"spec ready for review\", \"session_persisted\": true}}\n```\n\n---\n\n## 12. Metrics Tracking\n\n### 12.1 Metrics File Format\n\n```json\n{\n  \"updated_at\": \"2025-12-12T18:00:00Z\",\n  \"totals\": {\n    \"cost_all_time_usd\": 125.50,\n    \"goals_completed\": 47,\n    \"goals_total\": 52,\n    \"days_tracked\": 14,\n    \"autopilot_sessions\": 8,\n    \"autopilot_resumes\": 3\n  },\n  \"averages\": {\n    \"daily_cost_usd\": 8.96,\n    \"goal_completion_rate\": 0.904,\n    \"time_accuracy\": 0.82\n  },\n  \"streaks\": {\n    \"current_completion_streak\": 5,\n    \"best_completion_streak\": 8\n  },\n  \"by_week\": {\n    \"2025-W50\": {\n      \"cost_usd\": 45.20,\n      \"goals_completed\": 12,\n      \"goals_total\": 14\n    }\n  }\n}\n```\n\n### 12.2 Metrics Calculated\n\n| Metric | Calculation | Use |\n|--------|-------------|-----|\n| `daily_cost_usd` | `cost_all_time_usd / days_tracked` | Budget planning |\n| `goal_completion_rate` | `goals_completed / goals_total` | Performance tracking |\n| `time_accuracy` | `avg(min(actual, planned) / max(actual, planned))` | Estimation improvement |\n| `completion_streak` | Consecutive days with 100% completion | Motivation |\n| `autopilot_resume_rate` | `autopilot_resumes / autopilot_sessions` | Checkpoint effectiveness |\n\n---\n\n## 13. Implementation Notes\n\n### 13.1 State Gathering Performance\n\nTo meet the <30 second standup requirement:\n\n1. **Parallel Execution**: Gather from independent sources in parallel\n2. **GitHub Caching**: Cache GitHub results for 5 minutes\n3. **Lazy Test Collection**: Only run pytest --collect-only if tests.include enabled\n4. **Incremental Updates**: Only re-gather what changed since last check\n\n```python\nasync def gather(self, include_github: bool = True) -> RepoStateSnapshot:\n    \"\"\"Gather state with parallel execution.\"\"\"\n    tasks = [\n        self._gather_git_state(),\n        self._gather_features(),\n        self._gather_bugs(),\n        self._gather_prds(),\n        self._gather_specs(),\n        self._gather_interrupted_sessions(),\n    ]\n\n    if include_github:\n        tasks.append(self._gather_github_cached())\n\n    if self.config.standup.include_tests:\n        tasks.append(self._gather_tests())\n\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    # ... assemble snapshot\n```\n\n### 13.2 Spec Gathering Implementation\n\n```python\ndef gather_specs(self) -> list[SpecSummary]:\n    \"\"\"\n    Gather all specs from specs/*/ directories.\n\n    Scans specs/ directory for subdirectories containing spec files.\n    For each spec:\n    - Reads spec-draft.md or spec.md for title\n    - Checks for spec-review.json for review status\n    - Extracts scores if review exists\n\n    Returns:\n        List of SpecSummary objects.\n    \"\"\"\n    specs = []\n    specs_dir = Path(\"specs\")\n\n    if not specs_dir.exists():\n        return specs\n\n    for spec_dir in specs_dir.iterdir():\n        if not spec_dir.is_dir():\n            continue\n\n        feature_id = spec_dir.name\n\n        # Find spec file\n        spec_path = None\n        for name in [\"spec.md\", \"spec-draft.md\"]:\n            candidate = spec_dir / name\n            if candidate.exists():\n                spec_path = candidate\n                break\n\n        if not spec_path:\n            continue\n\n        # Extract title from first H1\n        title = feature_id\n        try:\n            content = spec_path.read_text()\n            for line in content.split(\"\\n\"):\n                if line.startswith(\"# \"):\n                    title = line[2:].strip()\n                    break\n        except Exception:\n            pass\n\n        # Check for review\n        review_path = spec_dir / \"spec-review.json\"\n        has_review = review_path.exists()\n        review_passed = False\n        review_scores = None\n\n        if has_review:\n            try:\n                review_data = json.loads(review_path.read_text())\n                review_passed = review_data.get(\"recommendation\") == \"APPROVE\"\n                review_scores = review_data.get(\"scores\")\n            except Exception:\n                pass\n\n        # Get modification time\n        updated_at = datetime.fromtimestamp(\n            spec_path.stat().st_mtime\n        ).isoformat()\n\n        specs.append(SpecSummary(\n            feature_id=feature_id,\n            title=title,\n            path=str(spec_path),\n            has_review=has_review,\n            review_passed=review_passed,\n            review_scores=review_scores,\n            updated_at=updated_at,\n        ))\n\n    return specs\n```\n\n### 13.3 Goal Reconciliation Implementation\n\n```python\ndef reconcile_with_state(self, snapshot: RepoStateSnapshot) -> list[dict[str, Any]]:\n    \"\"\"\n    Reconcile goal statuses with actual repository state.\n\n    Examines each goal's linked_feature, linked_bug, or linked_spec\n    and updates status based on actual state.\n    \"\"\"\n    changes = []\n    today_goals = self.get_today_goals()\n\n    # Build lookup maps\n    feature_phases = {f.feature_id: f.phase for f in snapshot.features}\n    bug_phases = {b.bug_id: b.phase for b in snapshot.bugs}\n    spec_reviews = {s.feature_id: s for s in snapshot.specs}\n\n    for goal in today_goals:\n        old_status = goal.status\n        new_status = old_status\n        reason = \"\"\n\n        # Check linked feature\n        if goal.linked_feature and goal.linked_feature in feature_phases:\n            phase = feature_phases[goal.linked_feature]\n            if phase == \"COMPLETE\":\n                new_status = GoalStatus.DONE\n                reason = f\"Feature {goal.linked_feature} completed\"\n            elif phase == \"BLOCKED\":\n                new_status = GoalStatus.BLOCKED\n                reason = f\"Feature {goal.linked_feature} is blocked\"\n            elif phase in (\"IMPLEMENTING\", \"SPEC_IN_PROGRESS\"):\n                if old_status == GoalStatus.PENDING:\n                    new_status = GoalStatus.IN_PROGRESS\n                    reason = f\"Feature {goal.linked_feature} now {phase}\"\n\n        # Check linked bug\n        elif goal.linked_bug and goal.linked_bug in bug_phases:\n            phase = bug_phases[goal.linked_bug]\n            if phase == \"fixed\":\n                new_status = GoalStatus.DONE\n                reason = f\"Bug {goal.linked_bug} fixed\"\n            elif phase == \"blocked\":\n                new_status = GoalStatus.BLOCKED\n                reason = f\"Bug {goal.linked_bug} is blocked\"\n\n        # Check linked spec\n        elif goal.linked_spec and goal.linked_spec in spec_reviews:\n            spec = spec_reviews[goal.linked_spec]\n            if spec.has_review and spec.review_passed:\n                new_status = GoalStatus.DONE\n                reason = f\"Spec {goal.linked_spec} review passed\"\n            elif spec.has_review and not spec.review_passed:\n                new_status = GoalStatus.PARTIAL\n                reason = f\"Spec {goal.linked_spec} needs revision\"\n\n        # Apply change if different\n        if new_status != old_status:\n            self.update_goal(goal.id, new_status, notes=reason)\n            changes.append({\n                \"goal_id\": goal.id,\n                \"old_status\": old_status.value,\n                \"new_status\": new_status.value,\n                \"reason\": reason,\n            })\n\n    return changes\n```\n\n### 13.4 Autopilot Session Persistence\n\n```python\nclass AutopilotSessionStore:\n    \"\"\"Persists autopilot sessions for pause/resume capability.\"\"\"\n\n    def __init__(self, base_path: Path) -> None:\n        self.base_path = base_path / \"autopilot\"\n        self.base_path.mkdir(parents=True, exist_ok=True)\n\n    def _session_path(self, session_id: str) -> Path:\n        return self.base_path / f\"{session_id}.json\"\n\n    def save(self, session: AutopilotSession) -> None:\n        \"\"\"Save autopilot session atomically.\"\"\"\n        session.last_persisted_at = datetime.now().isoformat()\n\n        path = self._session_path(session.session_id)\n        temp_path = path.with_suffix(\".tmp\")\n        backup_path = path.with_suffix(\".bak\")\n\n        try:\n            # Write to temp\n            temp_path.write_text(json.dumps(session.to_dict(), indent=2))\n\n            # Validate by re-reading\n            AutopilotSession.from_dict(json.loads(temp_path.read_text()))\n\n            # Backup existing\n            if path.exists():\n                shutil.copy2(path, backup_path)\n\n            # Atomic rename\n            temp_path.rename(path)\n\n            # Remove backup\n            if backup_path.exists():\n                backup_path.unlink()\n\n        except Exception as e:\n            if backup_path.exists():\n                shutil.copy2(backup_path, path)\n            if temp_path.exists():\n                temp_path.unlink()\n            raise\n\n    def load(self, session_id: str) -> Optional[AutopilotSession]:\n        \"\"\"Load autopilot session.\"\"\"\n        path = self._session_path(session_id)\n        if not path.exists():\n            return None\n\n        try:\n            data = json.loads(path.read_text())\n            return AutopilotSession.from_dict(data)\n        except Exception:\n            return None\n\n    def list_paused(self) -> list[str]:\n        \"\"\"List paused session IDs.\"\"\"\n        paused = []\n        for path in self.base_path.glob(\"*.json\"):\n            session = self.load(path.stem)\n            if session and session.status == \"paused\":\n                paused.append(session.session_id)\n        return paused\n```\n\n### 13.5 Autopilot Resume Implementation\n\n```python\ndef resume(self, session_id: str) -> AutopilotSession:\n    \"\"\"\n    Resume a paused autopilot session.\n\n    Loads session state, validates it can be resumed, and continues\n    execution from where it left off.\n    \"\"\"\n    session = self._session_store.load(session_id)\n    if not session:\n        raise ValueError(f\"Session {session_id} not found\")\n\n    if session.status != \"paused\":\n        raise ValueError(f\"Session {session_id} is {session.status}, not paused\")\n\n    # Update status to running\n    session.status = \"running\"\n    session.pause_reason = None\n\n    # Continue from current_goal_index\n    while session.current_goal_index < len(session.goals):\n        goal = session.goals[session.current_goal_index]\n\n        # Check for checkpoint triggers before execution\n        trigger = self._checkpoint_system.check_triggers(session, goal.content)\n        if trigger:\n            action = self.handle_checkpoint(session, trigger)\n            if action == \"pause\":\n                return session\n            elif action == \"abort\":\n                session.status = \"aborted\"\n                session.ended_at = datetime.now().isoformat()\n                self._session_store.save(session)\n                return session\n\n        # Execute goal\n        success, cost = self.execute_goal(goal)\n        session.cost_spent_usd += cost\n\n        if success:\n            goal.status = GoalStatus.DONE\n            goal.completed_at = datetime.now().isoformat()\n        else:\n            goal.status = GoalStatus.BLOCKED\n\n        session.current_goal_index += 1\n\n        # Persist after each goal\n        self._session_store.save(session)\n\n    # All goals complete\n    session.status = \"completed\"\n    session.ended_at = datetime.now().isoformat()\n    self._session_store.save(session)\n    return session\n```\n\n### 13.6 Atomic File Operations\n\nAll file writes use the atomic write pattern from existing code:\n\n```python\ndef _save_atomic(self, path: Path, content: str) -> None:\n    \"\"\"Atomic write with temp file and rename.\"\"\"\n    temp_path = path.with_suffix(\".tmp\")\n    backup_path = path.with_suffix(\".bak\")\n\n    try:\n        temp_path.write_text(content)\n\n        if path.exists():\n            shutil.copy2(path, backup_path)\n\n        temp_path.rename(path)\n        backup_path.unlink(missing_ok=True)\n\n    except Exception:\n        if backup_path.exists():\n            backup_path.rename(path)\n        raise\n```\n\n### 13.7 Recommendation Algorithm\n\n```python\ndef generate_recommendations(\n    self,\n    state: RepoStateSnapshot,\n) -> list[Recommendation]:\n    \"\"\"Generate prioritized recommendations.\"\"\"\n    recommendations = []\n\n    # P1: Blockers and approvals\n    for feature in state.features:\n        if feature.phase == \"SPEC_NEEDS_APPROVAL\":\n            recommendations.append(Recommendation(\n                priority=\"P1\",\n                task=f\"Approve {feature.feature_id} spec\",\n                estimated_cost_usd=0,\n                estimated_minutes=5,\n                rationale=\"Spec ready for review\",\n                linked_feature=feature.feature_id,\n                command=f\"swarm-attack approve {feature.feature_id}\",\n            ))\n\n    for bug in state.bugs:\n        if bug.phase == \"planned\":\n            recommendations.append(Recommendation(\n                priority=\"P1\",\n                task=f\"Review fix plan for {bug.bug_id}\",\n                estimated_cost_usd=0,\n                estimated_minutes=10,\n                rationale=\"Fix plan awaiting approval\",\n                linked_bug=bug.bug_id,\n                command=f\"swarm-attack bug approve {bug.bug_id}\",\n            ))\n\n    # P1: Spec reviews needing attention\n    for spec in state.specs:\n        if spec.has_review and not spec.review_passed:\n            avg_score = 0.0\n            if spec.review_scores:\n                avg_score = sum(spec.review_scores.values()) / len(spec.review_scores)\n            recommendations.append(Recommendation(\n                priority=\"P1\",\n                task=f\"Revise {spec.feature_id} spec (avg score: {avg_score:.2f})\",\n                estimated_cost_usd=0.50,\n                estimated_minutes=15,\n                rationale=\"Spec review failed, needs revision\",\n                linked_spec=spec.feature_id,\n                command=f\"swarm-attack run {spec.feature_id}\",\n            ))\n\n    # P1: Regressions\n    if state.tests.failing > 0:\n        recommendations.append(Recommendation(\n            priority=\"P1\",\n            task=f\"Fix {state.tests.failing} failing tests\",\n            estimated_cost_usd=2.0,\n            estimated_minutes=30,\n            rationale=\"Test regressions detected\",\n        ))\n\n    # P2: Continue in-progress work\n    for feature in state.features:\n        if feature.phase in (\"SPEC_IN_PROGRESS\", \"IMPLEMENTING\"):\n            recommendations.append(Recommendation(\n                priority=\"P2\",\n                task=f\"Continue {feature.feature_id}\",\n                estimated_cost_usd=5.0,\n                estimated_minutes=60,\n                rationale=\"Work in progress\",\n                linked_feature=feature.feature_id,\n                command=f\"swarm-attack run {feature.feature_id}\",\n            ))\n\n    # P2: PRDs ready for spec\n    for prd in state.prds:\n        if prd.phase == \"PRD_READY\":\n            # Check if feature exists\n            feature_exists = any(f.feature_id == prd.feature_id for f in state.features)\n            if not feature_exists:\n                recommendations.append(Recommendation(\n                    priority=\"P2\",\n                    task=f\"Initialize feature {prd.feature_id}\",\n                    estimated_cost_usd=0,\n                    estimated_minutes=1,\n                    rationale=\"PRD ready, feature not initialized\",\n                    command=f\"swarm-attack init {prd.feature_id}\",\n                ))\n            else:\n                recommendations.append(Recommendation(\n                    priority=\"P2\",\n                    task=f\"Generate spec for {prd.feature_id}\",\n                    estimated_cost_usd=1.0,\n                    estimated_minutes=15,\n                    rationale=\"PRD ready for spec generation\",\n                    linked_feature=prd.feature_id,\n                    command=f\"swarm-attack run {prd.feature_id}\",\n                ))\n\n    # Sort by priority\n    priority_order = {\"P1\": 0, \"P2\": 1, \"P3\": 2}\n    recommendations.sort(key=lambda r: priority_order.get(r.priority, 99))\n\n    return recommendations\n```\n\n---\n\n## 14. Dependencies\n\n### 14.1 External Dependencies\n\n| Package | Version | Purpose |\n|---------|---------|---------|\n| `rich` | existing | CLI output formatting |\n| `typer` | existing | CLI framework |\n| `pyyaml` | existing | Config parsing |\n| `filelock` | existing | Concurrent file access |\n\n### 14.2 Internal Dependencies\n\n| Module | Dependency |\n|--------|------------|\n| `state_gatherer.py` | `StateStore`, `BugStateStore`, config |\n| `daily_log.py` | models |\n| `goal_tracker.py` | `DailyLogManager`, models |\n| `standup.py` | `StateGatherer`, `DailyLogManager`, `GoalTracker` |\n| `autopilot_store.py` | models |\n| `autopilot.py` | `CheckpointSystem`, `GoalTracker`, `AutopilotSessionStore`, `Orchestrator`, `BugOrchestrator` |\n| CLI commands | All of the above |\n\n---\n\n## 15. Future Considerations (Phase 6)\n\n### 15.1 Preference Learning\n\nTrack patterns in human decisions to improve recommendations:\n\n```python\n@dataclass\nclass PreferencePattern:\n    \"\"\"A learned preference pattern.\"\"\"\n    pattern_type: str           # \"time_of_day\", \"task_type\", \"priority_override\"\n    observation_count: int\n    confidence: float\n    action: str                 # What to do when pattern matches\n```\n\n### 15.2 Personalized Estimates\n\nUse historical data to improve time/cost estimates:\n\n```python\ndef estimate_task(self, task_type: str, complexity: str) -> tuple[float, int]:\n    \"\"\"Estimate cost and time based on history.\"\"\"\n    historical = self._get_historical_tasks(task_type, complexity)\n    if len(historical) < 3:\n        return self._default_estimate(task_type, complexity)\n\n    avg_cost = sum(t.cost for t in historical) / len(historical)\n    avg_time = sum(t.duration for t in historical) / len(historical)\n\n    return avg_cost, avg_time\n```\n<<<SPEC_END>>>\n\n<<<RUBRIC_START>>>\n{\n  \"round\": 2,\n  \"previous_scores\": {\n    \"clarity\": 0.78,\n    \"coverage\": 0.55,\n    \"architecture\": 0.6,\n    \"risk\": 0.5\n  },\n  \"current_scores\": {\n    \"clarity\": 0.85,\n    \"coverage\": 0.88,\n    \"architecture\": 0.82,\n    \"risk\": 0.80\n  },\n  \"improvements\": [\n    {\n      \"dimension\": \"coverage\",\n      \"change\": \"+0.33\",\n      \"reason\": \"Added SpecSummary dataclass, gather_specs() method, and specs field on RepoStateSnapshot to fully model spec pipeline state per PRD requirements\"\n    },\n    {\n      \"dimension\": \"coverage\",\n      \"change\": \"+0.10\",\n      \"reason\": \"Extended AutopilotSession and AutopilotRunner to support --until trigger via stop_trigger parameter and matches_stop_trigger() method in CheckpointSystem\"\n    },\n    {\n      \"dimension\": \"coverage\",\n      \"change\": \"+0.08\",\n      \"reason\": \"Added reconcile_with_state() method to GoalTracker that auto-updates goal statuses based on linked_feature, linked_bug, and linked_spec fields matching actual repo state\"\n    },\n    {\n      \"dimension\": \"risk\",\n      \"change\": \"+0.30\",\n      \"reason\": \"Added AutopilotSessionStore for persisting sessions to .swarm/chief-of-staff/autopilot/, resume() method in AutopilotRunner, and --resume CLI flag to enable pause/resume workflow\"\n    },\n    {\n      \"dimension\": \"architecture\",\n      \"change\": \"+0.22\",\n      \"reason\": \"Added AutopilotSessionStore component, updated architecture diagram, and documented session persistence flow for checkpoint handling\"\n    },\n    {\n      \"dimension\": \"clarity\",\n      \"change\": \"+0.07\",\n      \"reason\": \"Added detailed implementation notes for spec gathering, goal reconciliation, and autopilot resume with code examples\"\n    }\n  ],\n  \"remaining_issues\": [\n    {\n      \"severity\": \"minor\",\n      \"description\": \"Weekly summary generation (generate_weekly_summary) is mentioned but not fully specified with template format\"\n    },\n    {\n      \"severity\": \"minor\",\n      \"description\": \"Error handling for concurrent autopilot sessions (what if user tries to start new while one is paused) not specified\"\n    }\n  ],\n  \"issues_addressed\": 4,\n  \"issues_remaining\": 2,\n  \"continue_debate\": false,\n  \"ready_for_approval\": true\n}\n<<<RUBRIC_END>>>",
  "session_id": "6e558f7d-60a5-4967-a093-a2432c69656d",
  "total_cost_usd": 1.18744575,
  "usage": {
    "input_tokens": 2,
    "cache_creation_input_tokens": 68299,
    "cache_read_input_tokens": 94168,
    "output_tokens": 22655,
    "server_tool_use": {
      "web_search_requests": 0,
      "web_fetch_requests": 0
    },
    "service_tier": "standard",
    "cache_creation": {
      "ephemeral_1h_input_tokens": 0,
      "ephemeral_5m_input_tokens": 68299
    }
  },
  "modelUsage": {
    "claude-haiku-4-5-20251001": {
      "inputTokens": 1033,
      "outputTokens": 144,
      "cacheReadInputTokens": 0,
      "cacheCreationInputTokens": 0,
      "webSearchRequests": 0,
      "costUSD": 0.0017530000000000002,
      "contextWindow": 200000
    },
    "claude-opus-4-5-20251101": {
      "inputTokens": 1163,
      "outputTokens": 28237,
      "cacheReadInputTokens": 94168,
      "cacheCreationInputTokens": 68299,
      "webSearchRequests": 0,
      "costUSD": 1.1856927499999999,
      "contextWindow": 200000
    }
  },
  "permission_denials": [],
  "uuid": "ed82306f-2931-46aa-a6e2-a64689ff024d"
}