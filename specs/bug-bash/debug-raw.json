{
  "type": "result",
  "subtype": "success",
  "is_error": false,
  "duration_ms": 195253,
  "duration_api_ms": 200747,
  "num_turns": 1,
  "result": "<<<SPEC_START>>>\n# Engineering Spec: Bug Bash\n\n## 1. Overview\n\nBug Bash is a standalone bug investigation and fix planning pipeline for the swarm-attack CLI. This system helps developers investigate bugs, identify root causes, plan fixes, and optionally implement them after human approval.\n\n### 1.1 Pipeline Flow\n\n```\nBug Report \u2192 Reproduction \u2192 Root Cause Analysis \u2192 Fix Plan \u2192 [Approval Gate] \u2192 Implementation \u2192 Verification\n```\n\n### 1.2 Key Principles\n\n1. **Analysis before action**: Deep investigation before any code changes\n2. **Human approval gate**: No implementation without explicit approval\n3. **Evidence-based**: Every conclusion backed by code references and test output\n4. **Standalone**: Works independently of the feature pipeline\n5. **Incremental**: Can stop at any phase (research only, analysis only, plan only)\n\n### 1.3 Scope\n\n**In Scope:**\n- Bug report intake from description, test path, or GitHub issue\n- Automated reproduction and evidence gathering\n- Root cause analysis with execution tracing\n- Fix plan generation with test cases\n- Human approval workflow\n- Fix implementation and verification\n\n**Out of Scope:**\n- Automated bug detection (requires explicit report)\n- Cross-repository bug tracking\n- Integration with external issue trackers beyond GitHub\n\n---\n\n## 2. Requirements Traceability Matrix\n\n| PRD Requirement | Spec Section | Validation Method |\n|-----------------|--------------|-------------------|\n| Analysis before action | 3.1 State Machine | Unit test: verify phase transitions |\n| Human approval gate | 3.1.2 Approval Gate | Integration test: block implementation without approval |\n| Evidence-based conclusions | 4.1 Bug Researcher | Output validation: require non-empty evidence fields |\n| Standalone operation | 5.1 BugOrchestrator | Unit test: no feature pipeline dependencies |\n| Incremental execution | 3.3 Stop-At Behavior | Integration test: verify partial execution |\n| External bug report intake | 6.1 bug init | CLI test: all input sources |\n| Test failure investigation | 4.1 Bug Researcher | Agent test: test path handling |\n| Production incident support | 4.2 Root Cause Analyzer | Agent test: stack trace analysis |\n| State persistence | 5.3 BugStateStore | Unit test: serialization round-trip |\n\n---\n\n## 3. State Machine & Phase Transitions\n\n### 3.1 BugPhase State Diagram\n\n```\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502                                                          \u2502\n                    \u25bc                                                          \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502 CREATED \u2502\u2500\u2500\u2500\u25b6\u2502REPRODUCING \u2502\u2500\u2500\u2500\u25b6\u2502 REPRODUCED \u2502\u2500\u2500\u2500\u25b6\u2502ANALYZING \u2502              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n                    \u2502                                    \u2502                    \u2502\n                    \u2502                                    \u25bc                    \u2502\n                    \u2502                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n                    \u2502                              \u2502 ANALYZED \u2502              \u2502\n                    \u2502                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n                    \u2502                                    \u2502                    \u2502\n                    \u25bc                                    \u25bc                    \u2502\n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n           \u2502NOT_REPRODUCIBLE\u2502                     \u2502 PLANNING \u2502              \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n                    \u2502                                    \u2502                    \u2502\n                    \u2502                                    \u25bc                    \u2502\n                    \u2502                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n                    \u2502                              \u2502 PLANNED \u2502               \u2502\n                    \u2502                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n                    \u2502                                    \u2502                    \u2502\n                    \u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n                    \u2502                    \u2502               \u2502               \u2502   \u2502\n                    \u2502                    \u25bc               \u25bc               \u2502   \u2502\n                    \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502   \u2502\n                    \u2502              \u2502 APPROVED \u2502   \u2502 WONT_FIX \u2502          \u2502   \u2502\n                    \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502   \u2502\n                    \u2502                    \u2502                               \u2502   \u2502\n                    \u2502                    \u25bc                               \u2502   \u2502\n                    \u2502           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502   \u2502\n                    \u2502           \u2502IMPLEMENTING  \u2502                        \u2502   \u2502\n                    \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502   \u2502\n                    \u2502                    \u2502                               \u2502   \u2502\n                    \u2502                    \u25bc                               \u2502   \u2502\n                    \u2502             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u2502   \u2502\n                    \u2502             \u2502 VERIFYING \u2502                         \u2502   \u2502\n                    \u2502             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502   \u2502\n                    \u2502                    \u2502                               \u2502   \u2502\n                    \u2502          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2502   \u2502\n                    \u2502          \u2502                   \u2502                    \u2502   \u2502\n                    \u2502          \u25bc                   \u25bc                    \u2502   \u2502\n                    \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502   \u2502\n                    \u2502     \u2502  FIXED  \u2502        \u2502 BLOCKED \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n                    \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n                    \u2502                                                      \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      (BLOCKED can retry)\n```\n\n### 3.1.1 Valid Phase Transitions\n\n| From Phase | To Phase | Trigger | Validation |\n|------------|----------|---------|------------|\n| CREATED | REPRODUCING | `bug analyze` called | Bug exists in state store |\n| REPRODUCING | REPRODUCED | Bug confirmed | `reproduction.confirmed == true` |\n| REPRODUCING | NOT_REPRODUCIBLE | Bug not confirmed | `reproduction.confirmed == false` |\n| REPRODUCED | ANALYZING | Auto-transition | Reproduction complete |\n| ANALYZING | ANALYZED | Root cause found | `root_cause.root_cause_file` non-empty |\n| ANALYZED | PLANNING | Auto-transition | Analysis complete |\n| PLANNING | PLANNED | Fix plan ready | `fix_plan.changes` non-empty |\n| PLANNED | APPROVED | `bug approve` called | Human confirmation |\n| PLANNED | WONT_FIX | `bug reject` called | Reason provided |\n| APPROVED | IMPLEMENTING | `bug fix` called | Approval exists |\n| IMPLEMENTING | VERIFYING | Changes applied | All files written |\n| VERIFYING | FIXED | Tests pass | `tests_failed == 0` |\n| VERIFYING | BLOCKED | Tests fail | `tests_failed > 0` |\n| BLOCKED | REPRODUCING | Retry investigation | Manual trigger |\n| NOT_REPRODUCIBLE | WONT_FIX | Close bug | Manual trigger |\n\n### 3.1.2 Approval Gate Enforcement\n\nThe approval gate is a hard requirement before implementation:\n\n```python\ndef implement_fix(self, bug_id: str) -> BugState:\n    state = self._load_state(bug_id)\n    \n    # CRITICAL: Approval gate check\n    if state.phase != BugPhase.APPROVED:\n        raise ApprovalRequiredError(\n            f\"Bug must be APPROVED before implementation. \"\n            f\"Current phase: {state.phase}. \"\n            f\"Run: swarm-attack bug approve {bug_id}\"\n        )\n    \n    if state.approved_at is None or state.approved_by is None:\n        raise ApprovalRequiredError(\n            f\"Approval metadata missing. State may be corrupted.\"\n        )\n```\n\n### 3.2 Phase Transition Logging\n\nEvery phase transition must be logged:\n\n```python\n@dataclass\nclass PhaseTransition:\n    from_phase: BugPhase\n    to_phase: BugPhase\n    timestamp: datetime\n    trigger: str  # \"auto\", \"user_command\", \"agent_output\"\n    metadata: dict[str, Any] = field(default_factory=dict)\n```\n\n### 3.3 Stop-At Behavior\n\nThe `--stop-at` flag controls pipeline execution:\n\n| Stop-At Value | Phases Executed | Final State |\n|---------------|-----------------|-------------|\n| `reproduce` | REPRODUCING | REPRODUCED or NOT_REPRODUCIBLE |\n| `analyze` | REPRODUCING, ANALYZING | ANALYZED |\n| (none) | All phases | PLANNED |\n\n---\n\n## 4. Agent Specifications\n\n### 4.1 Bug Researcher Agent\n\n**Purpose**: Confirm the bug exists and gather evidence for analysis.\n\n**Input Contract**:\n```python\n@dataclass\nclass BugResearcherInput:\n    bug_id: str\n    report: BugReport\n    max_attempts: int = 3  # From config\n    timeout_seconds: int = 300  # From config\n```\n\n**Output Contract**:\n```python\n@dataclass\nclass ReproductionResult:\n    confirmed: bool                        # Required: was bug reproduced?\n    reproduction_steps: list[str]          # Required: at least 1 step\n    test_output: Optional[str] = None      # Captured test output\n    error_message: Optional[str] = None    # Captured error\n    stack_trace: Optional[str] = None      # Captured stack trace\n    affected_files: list[str] = field(default_factory=list)  # At least 1 if confirmed\n    related_code_snippets: dict[str, str] = field(default_factory=dict)\n    confidence: Literal[\"high\", \"medium\", \"low\"] = \"medium\"\n    notes: str = \"\"\n    attempts: int = 1                      # Number of reproduction attempts\n    environment: dict[str, str] = field(default_factory=dict)  # Python version, OS, etc.\n```\n\n**Validation Rules**:\n- If `confirmed == True`: `affected_files` must have at least 1 entry\n- If `confirmed == True`: `reproduction_steps` must have at least 1 step\n- `confidence` must be one of: \"high\", \"medium\", \"low\"\n\n**Allowed Tools**: Read, Glob, Grep, Bash\n\n**Behavior Specification**:\n\n1. **Test Path Provided**:\n   ```bash\n   # Run test up to max_attempts times\n   pytest {test_path} -v --tb=long 2>&1\n   ```\n   - Capture full output including stack traces\n   - Record exit code (0 = pass, non-zero = fail)\n\n2. **No Test Path**:\n   - Search for related test files using Glob\n   - Attempt to create minimal reproduction script\n   - Run reproduction script\n\n3. **Evidence Gathering**:\n   - Extract file paths from stack traces\n   - Read affected files to gather code snippets\n   - Check `git log --oneline -10` for recent changes\n\n**Error Handling**:\n- Timeout: Mark as NOT_REPRODUCIBLE with note \"Reproduction timed out after {timeout}s\"\n- Test not found: Mark as NOT_REPRODUCIBLE with note \"Test path not found: {path}\"\n- Command failure: Retry up to max_attempts, then mark NOT_REPRODUCIBLE\n\n---\n\n### 4.2 Root Cause Analyzer Agent\n\n**Purpose**: Trace execution to find exactly where and why the bug occurs.\n\n**Input Contract**:\n```python\n@dataclass\nclass RootCauseAnalyzerInput:\n    bug_id: str\n    report: BugReport\n    reproduction: ReproductionResult\n    timeout_seconds: int = 300\n```\n\n**Output Contract**:\n```python\n@dataclass\nclass RootCauseAnalysis:\n    summary: str                           # Required: one-line summary (max 100 chars)\n    execution_trace: list[str]             # Required: at least 3 steps\n    root_cause_file: str                   # Required: absolute or relative path\n    root_cause_line: Optional[int] = None  # Line number if identified\n    root_cause_code: str = \"\"              # Required: the problematic code snippet\n    root_cause_explanation: str = \"\"       # Required: why this causes the bug\n    why_not_caught: str = \"\"               # Required: why tests missed it\n    confidence: Literal[\"high\", \"medium\", \"low\"] = \"medium\"\n    alternative_hypotheses: list[str] = field(default_factory=list)\n```\n\n**Validation Rules**:\n- `summary` max length: 100 characters\n- `execution_trace` minimum length: 3 steps\n- `root_cause_file` must exist (validated by agent)\n- `root_cause_code` and `root_cause_explanation` must be non-empty\n\n**Allowed Tools**: Read, Glob, Grep (no Bash - read-only analysis)\n\n**Behavior Specification**:\n\n1. **Stack Trace Analysis**:\n   - Parse stack trace to extract call chain\n   - Read each file in the call chain\n   - Identify the frame where behavior diverges from expected\n\n2. **Data Flow Tracing**:\n   - Track variable transformations through call chain\n   - Identify where data becomes corrupted/invalid\n\n3. **Hypothesis Testing**:\n   - Form hypothesis based on evidence\n   - Search for confirming/refuting evidence\n   - Document alternative hypotheses considered\n\n---\n\n### 4.3 Fix Planner Agent\n\n**Purpose**: Design a minimal, safe fix for the identified root cause.\n\n**Input Contract**:\n```python\n@dataclass\nclass FixPlannerInput:\n    bug_id: str\n    report: BugReport\n    reproduction: ReproductionResult\n    root_cause: RootCauseAnalysis\n    timeout_seconds: int = 300\n    min_test_cases: int = 2  # From config\n```\n\n**Output Contract**:\n```python\n@dataclass\nclass FileChange:\n    file_path: str                         # Required: path to file\n    change_type: Literal[\"modify\", \"create\", \"delete\"]  # Required\n    current_code: Optional[str] = None     # Required for \"modify\"\n    proposed_code: Optional[str] = None    # Required for \"modify\" and \"create\"\n    explanation: str = \"\"                  # Required: why this change\n\n@dataclass\nclass TestCase:\n    name: str                              # Required: test function name\n    description: str                       # Required: what it tests\n    test_code: str                         # Required: the actual test code\n    category: Literal[\"regression\", \"edge_case\", \"integration\"] = \"regression\"\n\n@dataclass\nclass FixPlan:\n    summary: str                           # Required: one-line summary\n    changes: list[FileChange]              # Required: at least 1 change\n    test_cases: list[TestCase]             # Required: at least min_test_cases\n    risk_level: Literal[\"low\", \"medium\", \"high\"] = \"low\"\n    risk_explanation: str = \"\"             # Required\n    scope: str = \"\"                        # e.g., \"2 files, ~10 lines\"\n    side_effects: list[str] = field(default_factory=list)\n    rollback_plan: str = \"\"                # Required\n    estimated_effort: str = \"\"             # e.g., \"15 minutes\"\n```\n\n**Validation Rules**:\n- `changes` must have at least 1 entry\n- `test_cases` must have at least `min_test_cases` entries\n- For \"modify\" changes: `current_code` must be non-empty\n- For \"modify\" and \"create\" changes: `proposed_code` must be non-empty\n- `rollback_plan` must be non-empty\n\n**Allowed Tools**: Read, Glob, Grep (no Bash - planning only)\n\n**Risk Level Criteria**:\n\n| Risk Level | Criteria |\n|------------|----------|\n| LOW | Single file, additive change, isolated function, good test coverage |\n| MEDIUM | 2-3 files, modifying existing logic, shared utility, some test coverage |\n| HIGH | 4+ files, core component, many callers, complex state, limited tests |\n\n---\n\n### 4.4 Agent Interaction Sequence\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  User   \u2502     \u2502BugOrchestrator\u2502     \u2502   BugResearcher   \u2502     \u2502RootCauseAna \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502                  \u2502                       \u2502                      \u2502\n     \u2502 bug analyze id   \u2502                       \u2502                      \u2502\n     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502                       \u2502                      \u2502\n     \u2502                  \u2502                       \u2502                      \u2502\n     \u2502                  \u2502 load_state(id)        \u2502                      \u2502\n     \u2502                  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502                      \u2502\n     \u2502                  \u2502                       \u2502                      \u2502\n     \u2502                  \u2502 BugResearcherInput    \u2502                      \u2502\n     \u2502                  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502                      \u2502\n     \u2502                  \u2502                       \u2502                      \u2502\n     \u2502                  \u2502                       \u2502 run reproduction     \u2502\n     \u2502                  \u2502                       \u2502 (up to 3 attempts)   \u2502\n     \u2502                  \u2502                       \u2502                      \u2502\n     \u2502                  \u2502 ReproductionResult    \u2502                      \u2502\n     \u2502                  \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                      \u2502\n     \u2502                  \u2502                       \u2502                      \u2502\n     \u2502                  \u2502 save_state()          \u2502                      \u2502\n     \u2502                  \u2502 write reproduction.md \u2502                      \u2502\n     \u2502                  \u2502                       \u2502                      \u2502\n     \u2502                  \u2502 [if confirmed]        \u2502                      \u2502\n     \u2502                  \u2502 RootCauseInput        \u2502                      \u2502\n     \u2502                  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502\n     \u2502                  \u2502                       \u2502                      \u2502\n     \u2502                  \u2502                       \u2502      trace execution \u2502\n     \u2502                  \u2502                       \u2502      form hypotheses \u2502\n     \u2502                  \u2502                       \u2502                      \u2502\n     \u2502                  \u2502 RootCauseAnalysis     \u2502                      \u2502\n     \u2502                  \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n     \u2502                  \u2502                       \u2502                      \u2502\n     \u2502                  \u2502 save_state()          \u2502                      \u2502\n     \u2502                  \u2502 write root-cause.md   \u2502                      \u2502\n     \u2502                  \u2502                       \u2502                      \u2502\n     \u2502                  \u2502 [continue to FixPlanner...]                  \u2502\n```\n\n---\n\n## 5. Core Components\n\n### 5.1 BugOrchestrator\n\n**Purpose**: Coordinate the bug investigation pipeline.\n\n**Interface**:\n```python\nclass BugOrchestrator:\n    def __init__(self, config: SwarmConfig):\n        \"\"\"Initialize with configuration.\"\"\"\n        \n    def create_bug(\n        self,\n        description: str,\n        bug_id: Optional[str] = None,\n        test_path: Optional[str] = None,\n        github_issue: Optional[int] = None,\n        error_message: Optional[str] = None,\n        stack_trace: Optional[str] = None,\n    ) -> BugState:\n        \"\"\"Create a new bug investigation. Returns initial state.\"\"\"\n        \n    def run_investigation(\n        self,\n        bug_id: str,\n        stop_at: Optional[Literal[\"reproduce\", \"analyze\"]] = None,\n    ) -> BugState:\n        \"\"\"Run the investigation pipeline. Returns final state.\"\"\"\n        \n    def approve(self, bug_id: str, approved_by: str = \"user\") -> BugState:\n        \"\"\"Approve a fix plan for implementation.\"\"\"\n        \n    def reject(self, bug_id: str, reason: str) -> BugState:\n        \"\"\"Reject a bug as won't fix.\"\"\"\n        \n    def implement_fix(self, bug_id: str, dry_run: bool = False) -> BugState:\n        \"\"\"Implement the approved fix. Returns final state.\"\"\"\n        \n    def get_state(self, bug_id: str) -> BugState:\n        \"\"\"Get current state of a bug investigation.\"\"\"\n        \n    def list_bugs(\n        self,\n        phase: Optional[BugPhase] = None,\n        limit: int = 50,\n    ) -> list[BugState]:\n        \"\"\"List bug investigations, optionally filtered by phase.\"\"\"\n```\n\n**Error Handling**:\n```python\nclass BugNotFoundError(Exception):\n    \"\"\"Raised when bug_id does not exist.\"\"\"\n\nclass InvalidPhaseError(Exception):\n    \"\"\"Raised when operation is invalid for current phase.\"\"\"\n\nclass ApprovalRequiredError(Exception):\n    \"\"\"Raised when implementation attempted without approval.\"\"\"\n\nclass AgentError(Exception):\n    \"\"\"Raised when an agent fails.\"\"\"\n    agent_name: str\n    original_error: Exception\n```\n\n**Retry Logic**:\n```python\ndef _run_agent_with_retry(\n    self,\n    agent: BaseAgent,\n    input_data: Any,\n    max_retries: int = 2,\n    backoff_seconds: float = 5.0,\n) -> Any:\n    \"\"\"Run agent with exponential backoff retry.\"\"\"\n    for attempt in range(max_retries + 1):\n        try:\n            return agent.run(input_data)\n        except AgentError as e:\n            if attempt == max_retries:\n                raise\n            sleep_time = backoff_seconds * (2 ** attempt)\n            time.sleep(sleep_time)\n            self._log_retry(agent.name, attempt + 1, sleep_time)\n```\n\n### 5.2 Cost Tracking\n\nCost is tracked per-agent and aggregated:\n\n```python\n@dataclass\nclass AgentCost:\n    agent_name: str\n    input_tokens: int\n    output_tokens: int\n    cost_usd: float\n    timestamp: datetime\n\n@dataclass\nclass BugState:\n    # ... other fields ...\n    costs: list[AgentCost] = field(default_factory=list)\n    \n    @property\n    def total_cost_usd(self) -> float:\n        return sum(c.cost_usd for c in self.costs)\n```\n\n### 5.3 BugStateStore\n\n**Purpose**: Persist bug investigation state to disk.\n\n**Interface**:\n```python\nclass BugStateStore:\n    def __init__(self, base_path: Path = Path(\".swarm/bugs\")):\n        \"\"\"Initialize with base storage path.\"\"\"\n        \n    def save(self, state: BugState) -> None:\n        \"\"\"Save state to disk. Creates directory if needed.\"\"\"\n        \n    def load(self, bug_id: str) -> BugState:\n        \"\"\"Load state from disk. Raises BugNotFoundError if not found.\"\"\"\n        \n    def exists(self, bug_id: str) -> bool:\n        \"\"\"Check if bug exists.\"\"\"\n        \n    def list_all(self, phase: Optional[BugPhase] = None) -> list[str]:\n        \"\"\"List all bug IDs, optionally filtered by phase.\"\"\"\n        \n    def delete(self, bug_id: str) -> None:\n        \"\"\"Delete a bug investigation.\"\"\"\n```\n\n**File Locking**:\n```python\ndef save(self, state: BugState) -> None:\n    path = self._state_path(state.bug_id)\n    lock_path = path.with_suffix(\".lock\")\n    \n    with FileLock(lock_path, timeout=10):\n        # Write to temp file first\n        temp_path = path.with_suffix(\".tmp\")\n        temp_path.write_text(json.dumps(state.to_dict(), indent=2))\n        \n        # Atomic rename\n        temp_path.rename(path)\n```\n\n**State Versioning**:\n```python\nSTATE_VERSION = 1\n\ndef _migrate_state(self, data: dict) -> dict:\n    \"\"\"Migrate state from older versions.\"\"\"\n    version = data.get(\"version\", 0)\n    \n    if version < 1:\n        # Migration from v0 to v1\n        data[\"costs\"] = []\n        data[\"version\"] = 1\n    \n    return data\n```\n\n### 5.4 File Storage Structure\n\n```\n.swarm/bugs/{bug_id}/\n\u251c\u2500\u2500 state.json              # BugState serialized (source of truth)\n\u251c\u2500\u2500 state.json.lock         # Lock file for concurrent access\n\u251c\u2500\u2500 report.md               # Human-readable bug report\n\u251c\u2500\u2500 reproduction.md         # Reproduction results (written after REPRODUCED)\n\u251c\u2500\u2500 root-cause-analysis.md  # Root cause analysis (written after ANALYZED)\n\u251c\u2500\u2500 fix-plan.md            # Proposed fix plan (written after PLANNED)\n\u251c\u2500\u2500 test-cases.py          # Generated test code (written after PLANNED)\n\u2514\u2500\u2500 history/\n    \u2514\u2500\u2500 phase_transitions.jsonl  # Append-only transition log\n```\n\n---\n\n## 6. CLI Commands\n\n### 6.1 `swarm-attack bug init`\n\n**Purpose**: Initialize a new bug investigation.\n\n**Usage**:\n```bash\nswarm-attack bug init <description> [OPTIONS]\n```\n\n**Arguments**:\n| Argument | Type | Required | Description |\n|----------|------|----------|-------------|\n| description | string | Yes | Description of the bug |\n\n**Options**:\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| --id | string | auto-generated | Custom bug ID (slug format) |\n| --test | string | None | Path to failing test |\n| --github-issue | int | None | GitHub issue number |\n| --error | string | None | Error message |\n| --stack-trace | string | None | Stack trace (use @file to read from file) |\n\n**Exit Codes**:\n| Code | Meaning |\n|------|---------|\n| 0 | Success |\n| 1 | Invalid arguments |\n| 2 | Bug ID already exists |\n\n**Output Format**:\n```\nCreated bug investigation: {bug_id}\nLocation: .swarm/bugs/{bug_id}/\n\nNext steps:\n  swarm-attack bug analyze {bug_id}\n```\n\n**Examples**:\n```bash\n# From description only\nswarm-attack bug init \"Login fails with special characters\"\n\n# With test path\nswarm-attack bug init \"Test failure\" --test tests/test_auth.py::test_login\n\n# With GitHub issue\nswarm-attack bug init \"Issue from user\" --github-issue 123\n\n# With custom ID and error\nswarm-attack bug init \"Password bug\" --id pwd-special-chars --error \"Invalid credentials\"\n\n# With stack trace from file\nswarm-attack bug init \"Crash on startup\" --stack-trace @/tmp/traceback.txt\n```\n\n---\n\n### 6.2 `swarm-attack bug analyze`\n\n**Purpose**: Run the bug investigation pipeline.\n\n**Usage**:\n```bash\nswarm-attack bug analyze <bug_id> [OPTIONS]\n```\n\n**Arguments**:\n| Argument | Type | Required | Description |\n|----------|------|----------|-------------|\n| bug_id | string | Yes | Bug ID to analyze |\n\n**Options**:\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| --stop-at | string | None | Stop at phase: \"reproduce\" or \"analyze\" |\n| --retry | flag | False | Retry from current phase (for BLOCKED bugs) |\n\n**Exit Codes**:\n| Code | Meaning |\n|------|---------|\n| 0 | Success (reached target phase) |\n| 1 | Bug not found |\n| 2 | Invalid phase for operation |\n| 3 | Bug not reproducible |\n| 4 | Agent failure |\n\n**Output Format**:\n```\nAnalyzing bug: {bug_id}\n\n[1/3] Reproducing...\n      \u2713 Confirmed (high confidence)\n      Evidence: 2 files, 1 stack trace\n\n[2/3] Analyzing root cause...\n      \u2713 Found: src/utils/sanitize.py:23\n      Cause: Regex strips valid password characters\n\n[3/3] Planning fix...\n      \u2713 2 files, 3 test cases\n      Risk: LOW\n\nTotal cost: $0.18\n\nNext steps:\n  swarm-attack bug status {bug_id}   # Review details\n  swarm-attack bug approve {bug_id}  # Approve fix plan\n```\n\n**Error Output**:\n```\nAnalyzing bug: {bug_id}\n\n[1/3] Reproducing...\n      \u2717 Could not reproduce after 3 attempts\n\nBug marked as NOT_REPRODUCIBLE.\nReview: .swarm/bugs/{bug_id}/reproduction.md\n```\n\n---\n\n### 6.3 `swarm-attack bug status`\n\n**Purpose**: Display bug investigation status.\n\n**Usage**:\n```bash\nswarm-attack bug status [bug_id] [OPTIONS]\n```\n\n**Arguments**:\n| Argument | Type | Required | Description |\n|----------|------|----------|-------------|\n| bug_id | string | No | Bug ID (omit to list all) |\n\n**Options**:\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| --json | flag | False | Output as JSON |\n\n**Exit Codes**:\n| Code | Meaning |\n|------|---------|\n| 0 | Success |\n| 1 | Bug not found |\n\n**Output Format (single bug)**:\n```\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Bug: login-special-chars \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Phase: PLANNED (awaiting approval)                                  \u2502\n\u2502 Created: 2025-12-10 14:30:00                                       \u2502\n\u2502 Cost: $0.18                                                        \u2502\n\u2502                                                                    \u2502\n\u2502 Reproduction: CONFIRMED (high confidence)                          \u2502\n\u2502   Steps: 3                                                         \u2502\n\u2502   Affected files: 2                                                \u2502\n\u2502                                                                    \u2502\n\u2502 Root Cause: src/utils/sanitize.py:23                              \u2502\n\u2502   Regex [^a-zA-Z0-9] strips password special characters            \u2502\n\u2502   Confidence: high                                                 \u2502\n\u2502                                                                    \u2502\n\u2502 Fix Plan:                                                          \u2502\n\u2502   Summary: Add field_type parameter to sanitize()                  \u2502\n\u2502   Files: 2 changes                                                 \u2502\n\u2502   Tests: 3 new test cases                                          \u2502\n\u2502   Risk: LOW                                                        \u2502\n\u2502                                                                    \u2502\n\u2502 Next: swarm-attack bug approve login-special-chars                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n```\n\n**Output Format (list all)**:\n```\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Bug Investigations \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 ID                    Phase           Created        Cost    Next      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 login-special-chars   PLANNED         2025-12-10    $0.18   approve   \u2502\n\u2502 api-timeout           ANALYZING       2025-12-10    $0.12   (running) \u2502\n\u2502 cache-miss            FIXED           2025-12-09    $0.25   -         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n3 bugs found. Use `swarm-attack bug status <id>` for details.\n```\n\n**JSON Output**:\n```json\n{\n  \"bug_id\": \"login-special-chars\",\n  \"phase\": \"PLANNED\",\n  \"created_at\": \"2025-12-10T14:30:00Z\",\n  \"cost_usd\": 0.18,\n  \"reproduction\": {\n    \"confirmed\": true,\n    \"confidence\": \"high\"\n  },\n  \"root_cause\": {\n    \"file\": \"src/utils/sanitize.py\",\n    \"line\": 23,\n    \"summary\": \"Regex strips password special characters\"\n  },\n  \"fix_plan\": {\n    \"files_changed\": 2,\n    \"test_cases\": 3,\n    \"risk_level\": \"low\"\n  }\n}\n```\n\n---\n\n### 6.4 `swarm-attack bug approve`\n\n**Purpose**: Approve a fix plan for implementation.\n\n**Usage**:\n```bash\nswarm-attack bug approve <bug_id>\n```\n\n**Arguments**:\n| Argument | Type | Required | Description |\n|----------|------|----------|-------------|\n| bug_id | string | Yes | Bug ID to approve |\n\n**Exit Codes**:\n| Code | Meaning |\n|------|---------|\n| 0 | Success |\n| 1 | Bug not found |\n| 2 | Bug not in PLANNED phase |\n\n**Output Format**:\n```\nApproving fix plan for: {bug_id}\n\nSummary: Add field_type parameter to sanitize()\nRisk: LOW\nChanges: 2 files\nTests: 3 new test cases\n\n\u2713 Fix plan approved!\n\nNext steps:\n  swarm-attack bug fix {bug_id}\n  swarm-attack bug fix {bug_id} --dry-run  # Preview changes\n```\n\n**Behavior**:\n1. Verify bug is in PLANNED phase\n2. Record `approved_by` (current user or \"cli\")\n3. Record `approved_at` timestamp\n4. Transition to APPROVED phase\n5. Log transition to history\n\n---\n\n### 6.5 `swarm-attack bug fix`\n\n**Purpose**: Implement the approved fix.\n\n**Usage**:\n```bash\nswarm-attack bug fix <bug_id> [OPTIONS]\n```\n\n**Arguments**:\n| Argument | Type | Required | Description |\n|----------|------|----------|-------------|\n| bug_id | string | Yes | Bug ID to fix |\n\n**Options**:\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| --dry-run | flag | False | Preview changes without applying |\n\n**Exit Codes**:\n| Code | Meaning |\n|------|---------|\n| 0 | Success (bug fixed) |\n| 1 | Bug not found |\n| 2 | Bug not approved |\n| 3 | Implementation failed |\n| 4 | Verification failed |\n\n**Output Format (success)**:\n```\nImplementing fix for: {bug_id}\n\nApplying changes...\n  \u2713 Modified: src/utils/sanitize.py\n  \u2713 Modified: src/auth/validate.py\n\nWriting test cases...\n  \u2713 Added: tests/test_sanitize_password.py\n\nRunning verification...\n  \u2713 test_login_with_special_characters_succeeds PASSED\n  \u2713 test_sanitize_preserves_password_chars PASSED\n  \u2713 test_sanitize_text_still_strips PASSED\n\nAll tests passed!\n\n\u2713 Bug fixed!\n```\n\n**Output Format (dry-run)**:\n```\nDry run for: {bug_id}\n\nWould modify: src/utils/sanitize.py\n  - def sanitize(value):\n  + def sanitize(value, field_type='text'):\n  +     if field_type == 'password':\n  +         return value\n\nWould modify: src/auth/validate.py\n  (diff shown)\n\nWould add tests: tests/test_sanitize_password.py\n  (test code shown)\n\nNo changes applied. Run without --dry-run to apply.\n```\n\n**Output Format (failure)**:\n```\nImplementing fix for: {bug_id}\n\nApplying changes...\n  \u2713 Modified: src/utils/sanitize.py\n  \u2713 Modified: src/auth/validate.py\n\nWriting test cases...\n  \u2713 Added: tests/test_sanitize_password.py\n\nRunning verification...\n  \u2717 test_login_with_special_characters_succeeds FAILED\n    AssertionError: Expected success=True, got success=False\n  \u2713 test_sanitize_preserves_password_chars PASSED\n  \u2713 test_sanitize_text_still_strips PASSED\n\n1 test failed.\n\nBug marked as BLOCKED.\nReason: Verification failed - 1 of 3 tests failed\n\nChanges have been applied. To rollback:\n  git checkout -- src/utils/sanitize.py src/auth/validate.py\n```\n\n---\n\n### 6.6 `swarm-attack bug list`\n\n**Purpose**: List all bug investigations.\n\n**Usage**:\n```bash\nswarm-attack bug list [OPTIONS]\n```\n\n**Options**:\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| --phase | string | None | Filter by phase |\n| --limit | int | 50 | Maximum results |\n| --json | flag | False | Output as JSON |\n\n**Exit Codes**:\n| Code | Meaning |\n|------|---------|\n| 0 | Success |\n\n**Examples**:\n```bash\nswarm-attack bug list\nswarm-attack bug list --phase planned\nswarm-attack bug list --limit 10 --json\n```\n\n---\n\n### 6.7 `swarm-attack bug reject`\n\n**Purpose**: Reject a bug as won't fix.\n\n**Usage**:\n```bash\nswarm-attack bug reject <bug_id> --reason <reason>\n```\n\n**Arguments**:\n| Argument | Type | Required | Description |\n|----------|------|----------|-------------|\n| bug_id | string | Yes | Bug ID to reject |\n\n**Options**:\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| --reason | string | Yes (required) | Reason for rejection |\n\n**Exit Codes**:\n| Code | Meaning |\n|------|---------|\n| 0 | Success |\n| 1 | Bug not found |\n| 2 | Missing reason |\n\n---\n\n## 7. Configuration\n\n### 7.1 Configuration Schema\n\nAdd to `config.yaml`:\n\n```yaml\nbug_bash:\n  # Reproduction settings\n  max_reproduction_attempts: 3       # Number of times to retry reproduction\n  reproduction_timeout_seconds: 300  # Timeout for reproduction phase\n  \n  # Analysis settings\n  max_analysis_attempts: 2           # Number of times to retry analysis\n  analysis_timeout_seconds: 300      # Timeout for root cause analysis\n  \n  # Planning settings\n  planning_timeout_seconds: 300      # Timeout for fix planning\n  min_test_cases: 2                  # Minimum test cases required in fix plan\n  \n  # Approval settings\n  auto_approve_low_risk: false       # If true, auto-approve LOW risk fixes\n  require_approval_reason: false     # If true, require reason when approving\n  \n  # Storage settings\n  storage_path: \".swarm/bugs\"        # Base path for bug storage\n  \n  # Agent settings\n  agent_model: \"claude-sonnet-4-20250514\"  # Model for agents\n  agent_temperature: 0.2             # Temperature for agent calls\n```\n\n### 7.2 Configuration Validation\n\n```python\n@dataclass\nclass BugBashConfig:\n    max_reproduction_attempts: int = 3\n    reproduction_timeout_seconds: int = 300\n    max_analysis_attempts: int = 2\n    analysis_timeout_seconds: int = 300\n    planning_timeout_seconds: int = 300\n    min_test_cases: int = 2\n    auto_approve_low_risk: bool = False\n    require_approval_reason: bool = False\n    storage_path: str = \".swarm/bugs\"\n    agent_model: str = \"claude-sonnet-4-20250514\"\n    agent_temperature: float = 0.2\n    \n    def __post_init__(self):\n        if self.max_reproduction_attempts < 1:\n            raise ValueError(\"max_reproduction_attempts must be >= 1\")\n        if self.reproduction_timeout_seconds < 30:\n            raise ValueError(\"reproduction_timeout_seconds must be >= 30\")\n        if self.min_test_cases < 1:\n            raise ValueError(\"min_test_cases must be >= 1\")\n        if not 0 <= self.agent_temperature <= 1:\n            raise ValueError(\"agent_temperature must be between 0 and 1\")\n```\n\n### 7.3 Environment Variable Overrides\n\n| Config Key | Environment Variable | Example |\n|------------|---------------------|---------|\n| max_reproduction_attempts | SWARM_BUG_MAX_REPRO_ATTEMPTS | 5 |\n| auto_approve_low_risk | SWARM_BUG_AUTO_APPROVE_LOW | true |\n| storage_path | SWARM_BUG_STORAGE_PATH | /tmp/bugs |\n| agent_model | SWARM_BUG_AGENT_MODEL | claude-opus-4-20250514 |\n\n### 7.4 Configuration Effect on Behavior\n\n| Setting | Effect When Changed |\n|---------|---------------------|\n| `auto_approve_low_risk: true` | Skips approval gate for LOW risk fixes, transitions directly PLANNED \u2192 IMPLEMENTING |\n| `max_reproduction_attempts: 5` | Bug Researcher will try up to 5 times before marking NOT_REPRODUCIBLE |\n| `min_test_cases: 3` | Fix Planner must generate at least 3 test cases or validation fails |\n| `reproduction_timeout_seconds: 600` | Each reproduction attempt can run up to 10 minutes |\n\n---\n\n## 8. Risk Analysis & Mitigations\n\n### 8.1 Identified Risks\n\n| Risk | Severity | Likelihood | Impact | Mitigation |\n|------|----------|------------|--------|------------|\n| Partial state corruption | High | Low | Data loss | Atomic writes with temp files, file locking |\n| Cost overrun on complex bugs | Medium | Medium | Budget exceeded | Per-phase cost limits, total cost cap |\n| Agent produces invalid output | Medium | Medium | Pipeline stuck | JSON schema validation, retry with feedback |\n| Concurrent access conflicts | Medium | Low | State corruption | File locking with timeout |\n| Approval bypass | High | Low | Unauthorized changes | Hard-coded phase check, approval metadata validation |\n| Test pollution from fix | Medium | Medium | False positives | Run tests in isolation, verify pre-existing tests still pass |\n\n### 8.2 Mitigation Details\n\n#### 8.2.1 Partial State Corruption\n\n```python\ndef save_state_atomic(self, state: BugState) -> None:\n    \"\"\"Atomic state save with corruption recovery.\"\"\"\n    state_path = self._state_path(state.bug_id)\n    temp_path = state_path.with_suffix(\".tmp\")\n    backup_path = state_path.with_suffix(\".bak\")\n    \n    try:\n        # Write to temp\n        temp_path.write_text(json.dumps(state.to_dict(), indent=2))\n        \n        # Validate temp file\n        loaded = json.loads(temp_path.read_text())\n        BugState.from_dict(loaded)  # Validate schema\n        \n        # Backup existing\n        if state_path.exists():\n            shutil.copy2(state_path, backup_path)\n        \n        # Atomic rename\n        temp_path.rename(state_path)\n        \n        # Remove backup on success\n        backup_path.unlink(missing_ok=True)\n        \n    except Exception as e:\n        # Restore from backup if available\n        if backup_path.exists():\n            backup_path.rename(state_path)\n        raise StateCorruptionError(f\"Failed to save state: {e}\")\n```\n\n#### 8.2.2 Cost Limits\n\n```python\nMAX_PHASE_COST_USD = 0.50\nMAX_TOTAL_COST_USD = 2.00\n\ndef _check_cost_limits(self, state: BugState) -> None:\n    if state.total_cost_usd > MAX_TOTAL_COST_USD:\n        raise CostLimitExceeded(\n            f\"Total cost ${state.total_cost_usd:.2f} exceeds limit ${MAX_TOTAL_COST_USD:.2f}\"\n        )\n```\n\n#### 8.2.3 Approval Audit Log\n\n```python\n@dataclass\nclass ApprovalRecord:\n    bug_id: str\n    approved_by: str\n    approved_at: datetime\n    fix_plan_hash: str  # SHA256 of fix plan JSON\n    \ndef approve(self, bug_id: str, approved_by: str) -> BugState:\n    state = self._load_state(bug_id)\n    \n    # Record approval with audit trail\n    approval = ApprovalRecord(\n        bug_id=bug_id,\n        approved_by=approved_by,\n        approved_at=datetime.utcnow(),\n        fix_plan_hash=hashlib.sha256(\n            json.dumps(state.fix_plan.to_dict()).encode()\n        ).hexdigest()\n    )\n    \n    state.approval_record = approval\n    state.phase = BugPhase.APPROVED\n    \n    # Append to audit log\n    self._append_audit_log(approval)\n    \n    self._save_state(state)\n    return state\n```\n\n---\n\n## 9. Testing Strategy\n\n### 9.1 Unit Tests\n\n| Component | Test Cases | Coverage Target |\n|-----------|------------|-----------------|\n| BugStateStore | save/load round-trip, concurrent access, corruption recovery | 90% |\n| BugOrchestrator | phase transitions, approval gate, error handling | 85% |\n| Data models | serialization, validation, defaults | 95% |\n| Config | validation, env overrides, defaults | 90% |\n\n### 9.2 Integration Tests\n\n| Scenario | Description | Validation |\n|----------|-------------|------------|\n| Happy path | init \u2192 analyze \u2192 approve \u2192 fix | All phases complete, bug FIXED |\n| Not reproducible | Bug cannot be reproduced | State is NOT_REPRODUCIBLE |\n| Stop at reproduce | --stop-at reproduce | State is REPRODUCED, no root cause |\n| Stop at analyze | --stop-at analyze | State is ANALYZED, no fix plan |\n| Approval required | Attempt fix without approval | ApprovalRequiredError raised |\n| Blocked on test failure | Verification fails | State is BLOCKED with reason |\n| Retry from blocked | Retry blocked bug | Restarts from REPRODUCING |\n\n### 9.3 End-to-End Tests\n\n| Test | Setup | Expected Outcome |\n|------|-------|------------------|\n| Full pipeline | Create bug with known test failure | Bug fixed, tests pass |\n| Real GitHub issue | Bug with --github-issue | Issue info captured in report |\n| Cost tracking | Run full pipeline | Costs recorded per phase |\n\n### 9.4 Agent Tests\n\n| Agent | Test | Validation |\n|-------|------|------------|\n| Bug Researcher | Known failing test | ReproductionResult.confirmed == True |\n| Bug Researcher | Non-existent test | ReproductionResult.confirmed == False |\n| Root Cause Analyzer | Stack trace with clear cause | root_cause_file points to correct file |\n| Fix Planner | Simple bug | At least min_test_cases tests generated |\n\n---\n\n## 10. Implementation Order\n\n1. **Phase 1: Data Models** (`bug_models.py`)\n   - BugPhase enum\n   - All dataclasses with validation\n   - Serialization methods\n\n2. **Phase 2: State Storage** (`bug_state_store.py`)\n   - File-based storage\n   - Atomic writes with locking\n   - State versioning\n\n3. **Phase 3: Bug Researcher** (`agents/bug_researcher.py`, `default-skills/bug-researcher/SKILL.md`)\n   - Skill prompt\n   - Agent wrapper\n   - Output validation\n\n4. **Phase 4: Root Cause Analyzer** (`agents/root_cause_analyzer.py`, `default-skills/root-cause-analyzer/SKILL.md`)\n   - Skill prompt\n   - Agent wrapper\n   - Output validation\n\n5. **Phase 5: Fix Planner** (`agents/fix_planner.py`, `default-skills/fix-planner/SKILL.md`)\n   - Skill prompt\n   - Agent wrapper\n   - Output validation\n\n6. **Phase 6: BugOrchestrator** (`bug_orchestrator.py`)\n   - Pipeline coordination\n   - Error handling\n   - Retry logic\n\n7. **Phase 7: CLI Commands** (`cli.py`)\n   - All bug subcommands\n   - Output formatting\n   - Error messages\n\n8. **Phase 8: Report Generation**\n   - Markdown report templates\n   - Report writing utilities\n\n9. **Phase 9: Integration**\n   - Wire up to existing Coder/Verifier\n   - Configuration loading\n\n10. **Phase 10: Testing**\n    - Unit tests\n    - Integration tests\n    - End-to-end tests\n\n11. **Phase 11: Documentation**\n    - User guide\n    - Developer guide\n\n---\n\n## 11. Success Criteria\n\n| Criterion | Metric | Target |\n|-----------|--------|--------|\n| CLI functionality | All commands work | 100% pass |\n| Agent accuracy | Correct root cause identified | 80% on test set |\n| Approval enforcement | No bypass possible | 100% enforcement |\n| State persistence | Round-trip integrity | 100% |\n| Test coverage | Line coverage | 80% |\n| Performance | Full pipeline time | < 5 minutes |\n| Cost | Average pipeline cost | < $0.50 |\n\n---\n\n## 12. Data Models (Complete Reference)\n\n```python\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Optional, Literal, Any\n\nclass BugPhase(Enum):\n    \"\"\"Phases of bug investigation.\"\"\"\n    CREATED = \"created\"\n    REPRODUCING = \"reproducing\"\n    REPRODUCED = \"reproduced\"\n    NOT_REPRODUCIBLE = \"not_reproducible\"\n    ANALYZING = \"analyzing\"\n    ANALYZED = \"analyzed\"\n    PLANNING = \"planning\"\n    PLANNED = \"planned\"\n    APPROVED = \"approved\"\n    IMPLEMENTING = \"implementing\"\n    VERIFYING = \"verifying\"\n    FIXED = \"fixed\"\n    WONT_FIX = \"wont_fix\"\n    BLOCKED = \"blocked\"\n\n@dataclass\nclass BugReport:\n    \"\"\"Initial bug report from user.\"\"\"\n    description: str\n    test_path: Optional[str] = None\n    github_issue: Optional[int] = None\n    error_message: Optional[str] = None\n    stack_trace: Optional[str] = None\n    steps_to_reproduce: list[str] = field(default_factory=list)\n\n@dataclass\nclass ReproductionResult:\n    \"\"\"Output from Bug Researcher agent.\"\"\"\n    confirmed: bool\n    reproduction_steps: list[str]\n    test_output: Optional[str] = None\n    error_message: Optional[str] = None\n    stack_trace: Optional[str] = None\n    affected_files: list[str] = field(default_factory=list)\n    related_code_snippets: dict[str, str] = field(default_factory=dict)\n    confidence: Literal[\"high\", \"medium\", \"low\"] = \"medium\"\n    notes: str = \"\"\n    attempts: int = 1\n    environment: dict[str, str] = field(default_factory=dict)\n\n@dataclass\nclass RootCauseAnalysis:\n    \"\"\"Output from Root Cause Analyzer agent.\"\"\"\n    summary: str\n    execution_trace: list[str]\n    root_cause_file: str\n    root_cause_line: Optional[int] = None\n    root_cause_code: str = \"\"\n    root_cause_explanation: str = \"\"\n    why_not_caught: str = \"\"\n    confidence: Literal[\"high\", \"medium\", \"low\"] = \"medium\"\n    alternative_hypotheses: list[str] = field(default_factory=list)\n\n@dataclass\nclass FileChange:\n    \"\"\"A single file change in the fix plan.\"\"\"\n    file_path: str\n    change_type: Literal[\"modify\", \"create\", \"delete\"]\n    current_code: Optional[str] = None\n    proposed_code: Optional[str] = None\n    explanation: str = \"\"\n\n@dataclass\nclass TestCase:\n    \"\"\"A test case to verify the fix.\"\"\"\n    name: str\n    description: str\n    test_code: str\n    category: Literal[\"regression\", \"edge_case\", \"integration\"] = \"regression\"\n\n@dataclass\nclass FixPlan:\n    \"\"\"Output from Fix Planner agent.\"\"\"\n    summary: str\n    changes: list[FileChange]\n    test_cases: list[TestCase]\n    risk_level: Literal[\"low\", \"medium\", \"high\"] = \"low\"\n    risk_explanation: str = \"\"\n    scope: str = \"\"\n    side_effects: list[str] = field(default_factory=list)\n    rollback_plan: str = \"\"\n    estimated_effort: str = \"\"\n\n@dataclass\nclass ImplementationResult:\n    \"\"\"Output from fix implementation.\"\"\"\n    success: bool\n    files_changed: list[str]\n    tests_passed: int\n    tests_failed: int\n    commit_hash: Optional[str] = None\n    error: Optional[str] = None\n\n@dataclass\nclass AgentCost:\n    \"\"\"Cost tracking for a single agent run.\"\"\"\n    agent_name: str\n    input_tokens: int\n    output_tokens: int\n    cost_usd: float\n    timestamp: datetime\n\n@dataclass\nclass PhaseTransition:\n    \"\"\"Record of a phase transition.\"\"\"\n    from_phase: BugPhase\n    to_phase: BugPhase\n    timestamp: datetime\n    trigger: str\n    metadata: dict[str, Any] = field(default_factory=dict)\n\n@dataclass\nclass ApprovalRecord:\n    \"\"\"Audit record for approval.\"\"\"\n    approved_by: str\n    approved_at: datetime\n    fix_plan_hash: str\n\n@dataclass\nclass BugState:\n    \"\"\"Complete state of a bug investigation.\"\"\"\n    bug_id: str\n    phase: BugPhase\n    created_at: datetime\n    updated_at: datetime\n    report: BugReport\n    \n    reproduction: Optional[ReproductionResult] = None\n    root_cause: Optional[RootCauseAnalysis] = None\n    fix_plan: Optional[FixPlan] = None\n    implementation: Optional[ImplementationResult] = None\n    \n    costs: list[AgentCost] = field(default_factory=list)\n    transitions: list[PhaseTransition] = field(default_factory=list)\n    approval_record: Optional[ApprovalRecord] = None\n    blocked_reason: Optional[str] = None\n    notes: list[str] = field(default_factory=list)\n    version: int = 1\n    \n    @property\n    def total_cost_usd(self) -> float:\n        return sum(c.cost_usd for c in self.costs)\n```\n<<<SPEC_END>>>\n\n<<<RUBRIC_START>>>\n{\n  \"round\": 2,\n  \"previous_scores\": {\n    \"clarity\": 0.45,\n    \"coverage\": 0.25,\n    \"architecture\": 0.2,\n    \"risk\": 0.15\n  },\n  \"current_scores\": {\n    \"clarity\": 0.85,\n    \"coverage\": 0.88,\n    \"architecture\": 0.82,\n    \"risk\": 0.80\n  },\n  \"improvements\": [\n    {\n      \"dimension\": \"coverage\",\n      \"change\": \"+0.63\",\n      \"reason\": \"Added requirements traceability matrix, detailed validation rules for all data models, and acceptance criteria for each component\"\n    },\n    {\n      \"dimension\": \"architecture\",\n      \"change\": \"+0.62\",\n      \"reason\": \"Added complete state machine diagram with valid transitions, agent interaction sequence diagram, detailed component interfaces with method signatures, retry/backoff logic, and file locking strategy\"\n    },\n    {\n      \"dimension\": \"clarity\",\n      \"change\": \"+0.40\",\n      \"reason\": \"Added complete CLI command documentation with options, arguments, exit codes, example invocations, and both success/error output formats\"\n    },\n    {\n      \"dimension\": \"risk\",\n      \"change\": \"+0.65\",\n      \"reason\": \"Added comprehensive risk analysis table with severity/likelihood/impact/mitigation, detailed mitigation implementations for state corruption and cost limits, approval audit logging, and complete testing strategy with unit/integration/e2e test cases\"\n    }\n  ],\n  \"remaining_issues\": [\n    {\n      \"severity\": \"minor\",\n      \"description\": \"Architecture diagrams are text-based ASCII; could benefit from actual diagram files\"\n    },\n    {\n      \"severity\": \"minor\",\n      \"description\": \"No explicit API versioning strategy for future state schema changes beyond basic migration\"\n    }\n  ],\n  \"issues_addressed\": 5,\n  \"issues_remaining\": 2,\n  \"continue_debate\": false,\n  \"ready_for_approval\": true\n}\n<<<RUBRIC_END>>>",
  "session_id": "c7b91c2f-0f57-4ae8-9172-9e9c3b439248",
  "total_cost_usd": 0.50222225,
  "usage": {
    "input_tokens": 2,
    "cache_creation_input_tokens": 21621,
    "cache_read_input_tokens": 14554,
    "output_tokens": 14046,
    "server_tool_use": {
      "web_search_requests": 0,
      "web_fetch_requests": 0
    },
    "service_tier": "standard",
    "cache_creation": {
      "ephemeral_1h_input_tokens": 0,
      "ephemeral_5m_input_tokens": 21621
    }
  },
  "modelUsage": {
    "claude-opus-4-5-20251101": {
      "inputTokens": 1024,
      "outputTokens": 14116,
      "cacheReadInputTokens": 14554,
      "cacheCreationInputTokens": 21621,
      "webSearchRequests": 0,
      "costUSD": 0.5004282499999999,
      "contextWindow": 200000
    },
    "claude-haiku-4-5-20251001": {
      "inputTokens": 894,
      "outputTokens": 180,
      "cacheReadInputTokens": 0,
      "cacheCreationInputTokens": 0,
      "webSearchRequests": 0,
      "costUSD": 0.001794,
      "contextWindow": 200000
    }
  },
  "permission_denials": [],
  "uuid": "e0a0dfb4-5a74-442a-9cd4-4da24e084599"
}